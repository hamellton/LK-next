import React, { useEffect, useRef, useState } from "react";
import { DeviceTypes, ThemeENUM, TypographyENUM } from "../../../../Types/general";
import { AddressFormType, FieldType, SubmitType } from "./AddAddressForm.types";
import { Form, InputWrapper, ReviewFormWrapper, LandmarkTextarea, AddressLabel, InvisibleButton, ButtonsContainer } from "./AddAddressForm.styles";
import AddressInputField from "../../AddressInputField";
import PhoneCodeDropdown from "../../PhonecodeDropdown";
// import Dropdown from "../../../Common/Dropdown/Dropdown.component";
import { Email, InfoCircle } from "../../../../Icons";
import AddressTextField from "../../AddressTextField";
import AddressSwatch from "../../AddressSwatch";
import AdvancedDropdown from "../../AdvancedDropdown";
import SvgOther from "../../../../Icons/Other";
import SvgWork from "../../../../Icons/Work";
import SvgHome from "../../../../Icons/Home";
import { Radio } from "../../NewPayment/components/Radio";
import { GenderText, SelectGender, EmailIconWrapper, GenderWrapper, EmptyComponent, PowerCheckout } from "./styles";
import { SubText } from "../../AddressInputField/styles";
import { getNumberLengthFromCode, isName, validateEmail, validateNumber, validateRequired } from "../../../../helpers";
import { ErrorField } from "../../SignInForm/styles";
import { PhoneCodeDropdownWrapper } from "../../Auth/SignIn/styles";

enum addressLabelENUM {
	HOME = "Home",
	WORK = "Work",
	OTHER = "Other"
}

// const specialCharRegex = /^[A-Za-z0-9 ]+$/g;

const AddAddressForm = ({
	id = "add-address-form",
	dataLocale = {
		FIRST_NAME: "First Name",
		LAST_NAME: "Last Name",
		MOBILE: "Mobile",
		EMAIL: "Email",
		ADDRESS_LINE_1: "Address Line 1",
		ADDRESS_LINE_2: "Address Line 2",
		ZIP_CODE: "Zip/Postal Code",
		CITY_DISTRICT: "City/District",
		COUNTRY: "Country",
		STATE_PROVINCE: "State/Province",
		CONTINUE: "CONTINUE",
		VIEW_SAVED_ADDRESS: "VIEW SAVED ADDRESS",
		ADD: "ADD",
		CANCEL: "CANCEL"
	},
	font = TypographyENUM.defaultBook,
	onSubmit = () => console.log("submit"),
	// onViewSaved = () => console.log("View Saved Address"),
	// onPincodeChanged = (pin) => console.log("Fetch status of Pincode", pin),
	countryList = {
		options: [],
		optionsText: "",
		optionValue: ""
	},
	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	stateList = {
		options: [],
		optionsText: "",
		optionValue: ""
	},
	isReturnExchange = false,
	initialAddressData = null,
	userEmail,
	userNumber,
	getPincodeData,
	phoneCode,
	submitRef,
	btnVisible,
	tempAddressData,
	updateTempAddressData,
	isRTL = false,
	configData,
	onCancel,
	currCountry = "",
	phoneCodeConfigData,
	deviceType,
	incCountryCodeFont,
	hasFrameProduct,
	InfoText,
}: AddressFormType) => {
	const { DESKTOP_ADDRESS_FORM, PINCODE_LENGTH = 6, VALIDATE_PINCODE = true, DESKTOP_ADDRESS_FORM_PLACEMENT_CONFIG } = configData;
	const desktopAddressFormConfig = DESKTOP_ADDRESS_FORM && JSON.parse(DESKTOP_ADDRESS_FORM as string);

	const desktopAddressPlacementFormConfig = DESKTOP_ADDRESS_FORM_PLACEMENT_CONFIG && JSON.parse(DESKTOP_ADDRESS_FORM_PLACEMENT_CONFIG as string);
	const initialCountry = countryList.options.length > 0 ? countryList.options[0].country_code : "";
	const [firstName, setFirstName] = useState(initialAddressData?.firstName || tempAddressData?.firstName || "");
	const [lastName, setLastName] = useState(initialAddressData?.lastName || tempAddressData?.lastName || tempAddressData?.lastName || "");
	const [mobile, setMobile] = useState(initialAddressData?.phone || tempAddressData?.mobile || userNumber || "");
	const [email, setEmail] = useState(initialAddressData?.email || tempAddressData?.email || userEmail || "");
	const [addressLine1, setAddressLine1] = useState(initialAddressData?.addressline1 || tempAddressData?.addressLine1 || "");
	const [addressLine2, setAddressLine2] = useState(initialAddressData?.addressline2 || tempAddressData?.addressLine2 || "");
	// const addressLine2 = initialAddressData?.addressline2 || tempAddressData?.addressLine2 || "";
	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	const [zipCode, setZipCode] = useState(initialAddressData?.postcode || tempAddressData?.zipCode || "");
	const [addressLabel, setAddressLabel] = useState(initialAddressData?.addressLabel || tempAddressData?.addressLabel || "");
	const [addressLabelTag, setAddressLabelTag] = useState(initialAddressData?.addressLabel ? (initialAddressData?.addressLabel === addressLabelENUM.HOME ? addressLabelENUM.HOME : (initialAddressData?.addressLabel === addressLabelENUM.WORK ? addressLabelENUM.WORK : (initialAddressData?.addressLabel ? addressLabelENUM.OTHER : ""))) : (tempAddressData?.addressLabel === addressLabelENUM.HOME ? addressLabelENUM.HOME : (tempAddressData?.addressLabel === addressLabelENUM.WORK ? addressLabelENUM.WORK : (tempAddressData?.addressLabel ? addressLabelENUM.OTHER : ""))));
	const [landmark, setLandmark] = useState(initialAddressData?.landmark || tempAddressData?.landmark || "");
	// const [showOtherAddressLabel, setShowOtherAddressLabel] = useState(false);
	const [cityDistrict, setCityDistrict] = useState(initialAddressData?.city || tempAddressData?.cityDistrict || "");
	const [country, setCountry] = useState(initialAddressData?.country || initialAddressData?.lkCountry || tempAddressData?.country || currCountry || initialCountry || "Saudi Arabia");
	const [state, setState] = useState(initialAddressData?.state || tempAddressData?.state || "");
	const [currentPhoneCode, setCurrentPhoneCode] = useState(initialAddressData?.phoneCode || phoneCode || tempAddressData?.currentPhoneCode || "+91");
	const [gender, setGender] = useState(initialAddressData?.gender || tempAddressData?.gender || "male");
	// const isRTL = false;
	const addressLabelRef = useRef<HTMLDivElement>(null);

	const [alphanumericPincode, setAlphaNumericPincode] = useState(false);
	const isMobileView = deviceType === DeviceTypes.MOBILE;

	const [errors, setErrors] = useState<{ [name: string]: string | boolean }>({
		// isError: false,
		firstName: "", //
		lastName: "",
		mobile: "", // +ph
		email: "", // +em
		addressLine1: "", //
		addressLine2: "",
		zipCode: "", // +pin
		addressLabel: "", //
		landmark: "",
		cityDistrict: "", // +should be valid as per pincode api
		country: "", // +should be valid as per pincode api
		state: "", // +should be valid as per pincode api
		currentPhoneCode: "", //
		gender: ""
	});

	useEffect(() => {
		// setZipCode(""); //* resetting zip code on country change as alphanumeric pincodes are not validated on api end for countries with pincode as number
		if (country?.toLowerCase() === "ca") {
			setAlphaNumericPincode(true);
		} else {
			setAlphaNumericPincode(false);
		}
	}, [country]);

	// const [swatchValue, setSwatchValue] = useState("Home");
	const submitForm = (e: React.FormEvent<HTMLFormElement>) => {
		e.preventDefault();
		// addressStepX 1
		if (validateAll()) {
			onSubmit(
				initialAddressData && initialAddressData.id ?
					SubmitType.edit :
					SubmitType.add,
				initialAddressData && initialAddressData.id ?
					initialAddressData.id :
					null,
				initialAddressData && initialAddressData.id ?
					{
						firstName: firstName,
						lastName: lastName,
						phone: mobile,
						email: email,
						addressline1: addressLine1,
						addressline2: addressLine2,
						postcode: zipCode || "000000",
						city: country.toUpperCase() === "SG" ? (state || "Singapore") : cityDistrict,
						state: country.toUpperCase() === "SG" ? "Singapore" : state,
						country: country,
						id: initialAddressData.id,
						addressLabel,
						landmark,
						phoneCode: currentPhoneCode,
						gender
					} : {
						firstName: firstName,
						lastName: lastName,
						phone: mobile,
						email: email,
						addressline1: addressLine1,
						addressline2: addressLine2,
						postcode: zipCode,
						city: country.toUpperCase() === "SG" ? (state || "Singapore") : cityDistrict,
						state: country.toUpperCase() === "SG" ? "Singapore" : state,
						country: country,
						addressLabel,
						landmark,
						phoneCode: currentPhoneCode,
						gender
					});
		}
	};

	function onChangeCountry(country: string, cartCall = true, prevCountry: string) {
		if (country && country !== prevCountry) {
			setZipCode(""); //* resetting zip code on country change as alphanumeric pincodes are not validated on api end for countries with pincode as number
			if (country === "SG") {
				setCountry(country);
				setCityDistrict("Singapore");
				setState("Singapore");
			}
			else {
				setCountry(country);
				// setCityDistrict("");
				// setState("");
			}
			if (country === "IN") {
				// getPincodeData(zipCode)
				// 	.then(data => console.log(data))
				// 	.catch(err => console.log(err));
			}
			if (cartCall && !isReturnExchange) {
				// countryShippingCheck(country);
			}
		}
	}

	function onFetchPincode(pin?: string) {
		// let isError = false;
		// isError = isError ||
		if (desktopAddressFormConfig?.zipCode?.isRendered && currentPhoneCode !== "+971") errorHandler("zipCode", validateRequired, pin || zipCode);
		if (!VALIDATE_PINCODE) return;

		const currentPin = pin || zipCode;
		if (currentPin && currentPin !== "000000") getPincodeData(currentPin)
			.then(data => {
				if (data?.isError) {
					setErrors(err => ({ ...err, zipCode: data.message }));
					// setCountry("");
					// setCityDistrict("");
					// setState("");
					// isError = true;
				}
				else if (data?.canDeliver) {
					setCountry(data.country);
					setCityDistrict(data.city);
					setState(data.state);
					setErrors(err => ({ ...err, zipCode: "", cityDistrict: "", state: "", country: "" }));
				}
			})
			.catch(err => {
				// isError = true;
				console.log(err, "Error");
			});
	}
	const swatchOptions = [{ icon: <SvgHome />, text: addressLabelENUM.HOME }, { icon: <SvgWork />, text: addressLabelENUM.WORK }, {
		icon:
			<SvgOther />, text: addressLabelENUM.OTHER
	}];

	function onAddressLabelChange(label: string) {
		if (addressLabelTag === label) {
			//
		} else if (label === addressLabelENUM.OTHER) {
			setAddressLabel("");
			setAddressLabelTag(label);
			// errorHandler("addressLabel", validateRequired, "");
		} else {
			setAddressLabel(label);
			setAddressLabelTag(label);
			setErrors(err => ({ ...err, addressLabel: "" }));
		}
	}
	// const hasErrors = (errors: {[name: string]: boolean}) => {
	// 	Object.keys(errors).filter(err => err !== "isError").forEach(err => {
	// 		if(errors[err]) return true;
	// 	});
	// 	if(!(firstName && mobile && email && addressLine1 && zipCode && addressLabel && cityDistrict && country && state)) return true;
	// 	if(!validateEmail())
	// 	return false;
	// };
	// const [fieldSwitch, setFieldSwitch] = useState(false);
	function errorHandler(key: string, cb: (...props: any) => string | boolean, ...val: any) {
		// setFieldSwitch(f => !f);
		if(desktopAddressFormConfig[key]?.isRequired){
			const error = cb(...val);
			// const newErrors = { ...errors };
			// setErrors(err => ({ ...err, err[key]: error, isError: !!error }));
			// newErrors[key] = error;
			// newErrors.isError = !!error;
			// console.log("newErrors", error, val, cb);
			setErrors(errors => {
				const newErrors = { ...errors };
				newErrors[key] = error;
				// newErrors.isError = !!error;
				return newErrors;
			});
			return !!error;
		}
	}

	// useEffect(() => {
	// 	if(disableAction && typeof disableAction === "function") disableAction(!!errors.isError);
	// 	console.log(errors);
	// }, [errors.isError, disableAction, fieldSwitch]);

	useEffect(() => {
		if (zipCode.length === 6 && VALIDATE_PINCODE) {
			// setErrors(err => ({ ...err, zipCode: "" }));
			onFetchPincode(zipCode);
		}
	}, [zipCode]);

	// function containsOnlyNumbers(str : string) {
	// 	return /^[0-9]+$/.test(str);
	// }

	// * if user previous enter character pincode for 'ca' and then switch to 'us', setting error
	// useEffect(() => {
	// 	if(!alphanumericPincode && !containsOnlyNumbers(zipCode) && zipCode !== ""){
	// 		setErrors({ ...errors, zipCode: dataLocale?.ONLY_NUMBERS_ALLOWED || "Only Numbers Allowed" });
	// 	}else{
	// 		setErrors({ ...errors, zipCode: "" });
	// 	}
	// }, [zipCode, country, alphanumericPincode]);

	useEffect(() => {
		return () => {
			updateTempAddressData({
				firstName: "",
				lastName: "",
				mobile: "",
				email: "",
				addressLine1: "",
				addressLine2: "",
				zipCode: "",
				addressLabel: "",
				landmark: "",
				cityDistrict: "",
				country: "",
				state: "",
				currentPhoneCode: "",
				gender: ""
			});
		};
	}, []);

	useEffect(() => {
		// On submit the prev state of the current input chaged was shown. For this reason we have commented return statement. Now the the updates are made on each character added in input fields.
		// return () => {
		// console.log("Update temp address data called");
		updateTempAddressData({ firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict, country, state, currentPhoneCode, gender });
		// storeTempAddressData({ firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict: "", country: "", state: "", currentPhoneCode: "", gender }, guestEmail, guestNumber);
		//only store once there is a change in value
		//delete on address submit
		//delete on add new address click
		//delete on user credentials change
		//delete after 5mins
		//if guest info exists, user can move forward from login to address
		//store guestNumber/guestEmail along with this and check if once coming back to this page, the same creds are there, if so
		//read this and pass it to this component in props
		// };
	}, [firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict, country, state, currentPhoneCode, gender]);


	// console.log({ addressLabel, addressLabelTag, labelerr: errors.addressLabel }, "addresslabel =================");
	function validateAll() {
		let isError = false;
		isError = desktopAddressFormConfig?.firstName?.isRendered && desktopAddressFormConfig?.firstName?.isRequired && errorHandler("firstName", isName, firstName) || isError;
		isError = desktopAddressFormConfig?.lastName?.isRendered && desktopAddressFormConfig?.lastName?.isRequired && errorHandler("lastName", isName, lastName) || isError;
		isError = desktopAddressFormConfig?.mobile?.isRendered && desktopAddressFormConfig?.mobile?.isRequired && errorHandler("mobile", validateNumber, mobile, currentPhoneCode) || isError;
		isError = desktopAddressFormConfig?.gender?.isRendered && desktopAddressFormConfig?.gender?.isRequired && errorHandler("gender", validateRequired, gender) || isError;
		isError = desktopAddressFormConfig?.email?.isRendered && desktopAddressFormConfig?.email?.isRequired && errorHandler("email", validateEmail, email) || isError;
		isError = desktopAddressFormConfig?.addressLine1?.isRendered && desktopAddressFormConfig?.addressLine1?.isRequired && errorHandler("addressLine1", validateRequired, addressLine1) || isError;
		isError = desktopAddressFormConfig.addressLine2.isRendered && desktopAddressFormConfig?.addressLine2?.isRequired && errorHandler("addressLine2", validateRequired, addressLine2) || isError;
		isError = desktopAddressFormConfig?.cityDistrict?.isRendered && desktopAddressFormConfig?.cityDistrict?.isRequired && errorHandler("cityDistrict", validateRequired, cityDistrict) || isError;
		isError = desktopAddressFormConfig?.state?.isRendered && desktopAddressFormConfig?.state?.isRequired && errorHandler("state", validateRequired, state) || isError;
		isError = desktopAddressFormConfig?.country?.isRendered && desktopAddressFormConfig?.country?.isRequired && errorHandler("country", validateRequired, country) || isError;
		isError = desktopAddressFormConfig?.zipCode?.isRendered && desktopAddressFormConfig?.zipCode?.isRequired && currentPhoneCode !== "+971" && errorHandler("zipCode", validateRequired, zipCode) || isError;
		isError = desktopAddressFormConfig?.addressLabel?.isRendered && desktopAddressFormConfig?.addressLabel?.isRequired && errorHandler("addressLabel", validateRequired, addressLabel) || isError;
		// onFetchPincode(zipCode);
		// Object.values(errors).forEach(err => {
		// 	if(err) isError = true;
		// });
		if (isError && errorHandler("addressLabel", validateRequired, addressLabel) && addressLabelRef.current) addressLabelRef.current?.scrollIntoView();
		return !isError;
	}

	const firstNameComponent = () => {
		return <>
			{desktopAddressFormConfig?.firstName?.isRendered && (
				<AddressInputField
					font={font}
					isError={!!errors.firstName}
					subText={(errors.firstName as string)}
					isFullWidth
					disabled={desktopAddressFormConfig.firstName.disabled}
					label={`${dataLocale.FIRST_NAME}*`}
					labelLeftGap={16}
					value={firstName}
				>
					<AddressTextField
						isRTL={isRTL}
						value={firstName}
						validRegexPattern={desktopAddressFormConfig.firstName.validRegexPattern}
						onChange={e => setFirstName(e.target.value)}
						placeholder=""
						clearText={() => setFirstName("")}
						onBlur={(e) => errorHandler("firstName", isName, e.target.value)}
						disabled={desktopAddressFormConfig.firstName.disabled}
					/>
				</AddressInputField>
			)}</>;
	};

	const lastNameComponent = () => {
		return <>
			{desktopAddressFormConfig?.lastName?.isRendered && (
				<AddressInputField
					font={font}
					isError={!!errors.lastName}
					subText={(errors.lastName as string)}
					isFullWidth
					label={`${dataLocale.LAST_NAME}*`}
					disabled={desktopAddressFormConfig.lastName.disabled}
					labelLeftGap={16}
					value={lastName}
				>
					<AddressTextField
						isRTL={isRTL}
						value={lastName}
						onChange={e => setLastName(e.target.value)}
						validRegexPattern={desktopAddressFormConfig.lastName.validRegexPattern}
						placeholder=""
						clearText={() => setLastName("")}
						onBlur={(e) => errorHandler("lastName", isName, e.target.value)}
						disabled={desktopAddressFormConfig.lastName.disabled}
					/>
				</AddressInputField>
			)}</>;
	};

	const genderComponent = () => {
		return <GenderWrapper noGap={true}>{desktopAddressFormConfig?.gender?.isRendered && (
			<React.Fragment>
				<InputWrapper>
					<SelectGender marginBottom={true}>{`${dataLocale?.SELECT_GENDER} ${dataLocale?.SYMBOL_ASTRIX}`}</SelectGender>
				</InputWrapper>
				<InputWrapper>
					{desktopAddressPlacementFormConfig.genderConfig.map((config: { key: React.SetStateAction<string>; label: string | number | boolean | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactFragment | React.ReactPortal | null | undefined; }) => {
						return <><Radio
							isSelected={gender === config.key}
							onClick={() => setGender(config.key)}
							disabled={desktopAddressFormConfig.gender.disabled}
						/>
						<GenderText>{config.label}</GenderText></>;
					})}
				</InputWrapper>
				{/* <InputWrapper>
					<Radio
						isSelected={gender === "male"}
						onClick={() => setGender("male")}
						disabled={desktopAddressFormConfig.gender.disabled}
					/>
					<GenderText>{dataLocale.MALE}</GenderText>
					<Radio
						isSelected={gender === "female"}
						onClick={() => setGender("female")}
						disabled={desktopAddressFormConfig.gender.disabled}
					/>
					<GenderText>{dataLocale.FEMALE}</GenderText>
				</InputWrapper> */}
				<SubText isError={!!errors.gender}>{errors.gender}</SubText>
			</React.Fragment>
		)}</GenderWrapper>;
	};

	const mobileComponent = () => {
		return <>
			{desktopAddressFormConfig?.mobile?.isRendered && (
				<AddressInputField
					font={font}
					isError={!!errors.mobile}
					subText={(errors.mobile as string)}
					isFullWidth
					disabled={desktopAddressFormConfig.mobile.disabled}
					isRTL={isRTL}
					placeholder={`${dataLocale.PHONE_NUMBER}*`}
					// label={`${dataLocale.PHONE_NUMBER}*`}
					// labelLeftGap={92}
					// value={mobile}
				>
					<AddressTextField
						isRTL={isRTL}
						value={mobile}
						onChange={e => setMobile(e.target.value)}
						clearText={() => setMobile("")}
						type="text"
						maxLength={getNumberLengthFromCode(currentPhoneCode)}
						validRegexPattern={desktopAddressFormConfig.mobile.validRegexPattern}
						onBlur={(e) => errorHandler("mobile", validateNumber, e.target.value, currentPhoneCode)}
						placeholder={`${dataLocale.PHONE_NUMBER}*`}

						onKeyPress={(event: any) => {
							const keycode = event.which;
							if (
								!(
									event.shiftKey === false &&
											(keycode === 46 ||
												keycode === 8 ||
												keycode === 37 ||
												keycode === 39 ||
												(keycode >= 48 && keycode <= 57))
								)
							) {
								event.preventDefault();
							}
						}}
						disabled={desktopAddressFormConfig?.mobile?.disabled}
						shiftCross={true}
						rightPadding={true}>
						<PhoneCodeDropdownWrapper top={incCountryCodeFont ? "0" : "2"}>
							<PhoneCodeDropdown
								availableCountries={configData?.SUPPORT_MULTIPLE_COUNTRIES ? phoneCodeConfigData?.availableCountries ? phoneCodeConfigData?.availableCountries : [{ code: phoneCode }] : null}
								currentPhoneCode={currentPhoneCode}
								onChange={(newPhoneCode: string) => setCurrentPhoneCode(newPhoneCode)}
								disabled={desktopAddressFormConfig.mobile.disabled}
								showSvgArrow = {true}
								incCountryCodeFont={incCountryCodeFont}
								isMobileView={isMobileView}
								width={isMobileView ? "" : "68px"}
							/>
						</PhoneCodeDropdownWrapper>
					</AddressTextField>
				</AddressInputField>
			)}
		</>;
	};

	const emailComponent = () => {
		return <>{desktopAddressFormConfig?.email?.isRendered && (
			<AddressInputField
				font={font}
				isError={!!errors.email}
				subText={(errors.email as string)}
				isFullWidth
				// label={`${dataLocale.EMAIL_ADDRESS}*`}
				disabled={desktopAddressFormConfig.email.disabled}
				placeholder={`${dataLocale.EMAIL_ADDRESS}*`}
				// value={email}
				// labelLeftGap={37}
			>
				<AddressTextField
					isRTL={isRTL}
					value={email}
					onChange={e => setEmail(e.target.value)}
					clearText={() => setEmail("")}
					onBlur={(e) => errorHandler("email", validateEmail, e.target.value)}
					validRegexPattern={desktopAddressFormConfig.email.validRegexPattern}
					placeholder={`${dataLocale.EMAIL_ADDRESS}*`}
					disabled={desktopAddressFormConfig.email.disabled}
				>
					<EmailIconWrapper>
						<Email />
					</EmailIconWrapper>
				</AddressTextField>
			</AddressInputField>
		)}</>;
	};

	const addressLine1Component = () => {
		return <>{desktopAddressFormConfig?.addressLine1?.isRendered && (
			<AddressInputField
				font={font}
				subText={(errors.addressLine1 as string) || dataLocale.ADDRESSLINE1_SUB_TEXT}
				isError={!!errors.addressLine1}
				isFullWidth
				disabled={desktopAddressFormConfig.firstName.disabled}
				value={addressLine1}
				labelLeftGap={16}
				label={`${dataLocale.ADDRESS}*`}

			>
				<AddressTextField
					isRTL={isRTL}
					value={addressLine1}
					onChange={e => setAddressLine1(e.target.value)}
					placeholder=""
					clearText={() => setAddressLine1("")}
					validRegexPattern={desktopAddressFormConfig.addressLine1.validRegexPattern}
					onBlur={(e) => errorHandler("addressLine1", validateRequired, e.target.value)}
					disabled={desktopAddressFormConfig.firstName.disabled}
				/>
			</AddressInputField>
		)}</>;
	};

	const addressLine2Component = () => {
		return <>{desktopAddressFormConfig.addressLine2.isRendered && (
			<AddressInputField
				font={font}
				subText={(errors.addressLine2 as string) || dataLocale.ADDRESSLINE2_SUB_TEXT}
				isError={!!errors.addressLine2}
				disabled={desktopAddressFormConfig.addressLine2.disabled}
				isFullWidth
				value={addressLine2}
				labelLeftGap={16}
				label={dataLocale.ADDRESS_LINE_2}

			>
				<AddressTextField
					isRTL={isRTL}
					value={addressLine2}
					onChange={e => setAddressLine2(e.target.value)}
					placeholder=""
					clearText={() => setAddressLine2("")}
					validRegexPattern={desktopAddressFormConfig.addressLine2.validRegexPattern}
					onBlur={(e) => errorHandler("addressLine2", validateRequired, e.target.value)}
					disabled={desktopAddressFormConfig.addressLine2.disabled}
				/>
			</AddressInputField>
		)}</>;
	};

	const emptyComponent = () => {
		return <EmptyComponent style={{ width:"100%", visibility:"hidden" }}></EmptyComponent>;
	};

	const zipcodeComponent = () => {
		return <>{desktopAddressFormConfig?.zipCode?.isRendered && country.toLowerCase() !== "ae" && currentPhoneCode !== "+971" && (
			<AddressInputField
				font={font}
				subText={(errors.zipCode as string || dataLocale.PLEASE_ENTER_A_POSTAL_CODE)}
				isError={!!errors.zipCode}
				isFullWidth
				disabled={desktopAddressFormConfig.zipCode.disabled}
				value={zipCode}
				labelLeftGap={16}
				label={`${dataLocale.ZIP_CODE}*`}
			>
				<AddressTextField
					isRTL={isRTL}
					value={zipCode}
					onChange={e => setZipCode(e.target.value)}
					placeholder=""
					clearText={() => setZipCode("")}
					onBlur={(e) => onFetchPincode(e.target.value)}
					validRegexPattern={desktopAddressFormConfig.zipCode.validRegexPattern}
					maxLength={PINCODE_LENGTH as number}
					onKeyPress={(event: any) => {
						if (alphanumericPincode) return;
						const keycode = event.which;
						if (
							!(
								event.shiftKey === false &&
								(keycode === 46 ||
									keycode === 8 ||
									keycode === 37 ||
									keycode === 39 ||
									(keycode >= 48 && keycode <= 57))
							)
						) {
							event.preventDefault();
						}
					}}
					disabled={desktopAddressFormConfig.zipCode.disabled}
				/>
			</AddressInputField>
		)}</>;
	};

	const cityDistrictComponent = () => {
		return <>{desktopAddressFormConfig?.cityDistrict?.isRendered && (
			<AddressInputField
				font={font}
				subText={(errors.cityDistrict as string)}
				isError={!!errors.cityDistrict}
				isFullWidth
				disabled={desktopAddressFormConfig.cityDistrict.disabled}
				value={cityDistrict}
				labelLeftGap={16}
				label={`${dataLocale.CITY_DISTRICT}*`}

			>
				<AddressTextField
					isRTL={isRTL}
					value={cityDistrict}
					onChange={e => {
						// if((specialCharRegex.test(e.target.value) || !e.target.value)){
						setCityDistrict(e.target.value);
						// }
					}}
					onKeyPress={(event: any) => {
						const keycode = event.which;
						if (
							((keycode >= 32 && keycode <= 47) ||
								(keycode >= 58 && keycode <= 64) ||
								(keycode >= 91 && keycode <= 96) ||
								(keycode >= 123 && keycode <= 126))

						) {
							event.preventDefault();
						}
					}}
					validRegexPattern={desktopAddressFormConfig.cityDistrict.validRegexPattern}
					placeholder=""
					onBlur={(e) => errorHandler("cityDistrict", validateRequired, e.target.value)}
					disabled={desktopAddressFormConfig.cityDistrict.disabled}
				/>
			</AddressInputField>
		)}</>;
	};

	const stateComponent = () => {
		return <>{desktopAddressFormConfig?.state?.isRendered && (
			<div style={{ width: "100%" }}>
				{desktopAddressFormConfig.state.type === FieldType.INPUT && (
					<AddressInputField
						font={font}
						subText={(errors.state as string)}
						isError={!!errors.state}
						isFullWidth
						disabled={desktopAddressFormConfig.state.disabled}
						value={state}
						labelLeftGap={16}
						label={`${dataLocale.SELECT_STATE}*`}

					>
						<AddressTextField
							isRTL={isRTL}
							value={state}
							onChange={e => {

								// if((specialCharRegex.test(e.target.value) || !e.target.value)){
								setState(e.target.value);
								// }
							}}
							onKeyPress={(event: any) => {
								const keycode = event.which;
								if (

									((keycode >= 32 && keycode <= 47) ||
										(keycode >= 58 && keycode <= 64) ||
										(keycode >= 91 && keycode <= 96) ||
										(keycode >= 123 && keycode <= 126))

								) {
									event.preventDefault();
								}
							}}
							placeholder=""
							validRegexPattern={desktopAddressFormConfig.state.validRegexPattern}
							onBlur={(e) => errorHandler("state", validateRequired, e.target.value)}
							disabled={desktopAddressFormConfig.state.disabled}
						/>
					</AddressInputField>
				)}
				{desktopAddressFormConfig.state.type === FieldType.DROPDOWN && (
					<>
						<AdvancedDropdown
							id="state-options"
							value={state}
							// componentSize={ComponentSizeENUM.large}
							font={font}
							fullWidth={true}
							// options={stateList.options.map(op => ({ key: op, value: op }))}
							// dataLocale={dataLocale}
							// handleChange={e => setState(e.target.value)}
							onBlur={(val: string) => errorHandler("state", validateRequired, val)}
							placeholder={`${dataLocale.SELECT_STATE}`}
							selectedValue={state}
							mainFontColor="#000"
							mainBackgroundColor="#fff"
							inputLabel={`${dataLocale.STATE}*`}
							values={stateList.options.map(data => ({
								display: data,
								value: data.toUpperCase(),
								onChange: (e: any) => {
									setState(e.target.value);
								},
							}))}
							// menuItemStyles=""
							// styles=""
							// className = ""
							disabled={desktopAddressFormConfig.state.disabled}
							isRTL={isRTL}
						// styles={{ fontSize: '16px', width: '100%' }}
						/>
						{errors.state && <ErrorField>{errors.state}</ErrorField>}
					</>
				)}
			</div>
		)}</>;
	};

	const countryComponent = () => {
		return <>{desktopAddressFormConfig?.country?.isRendered && (
			<div style={{ width: "100%" }}>
				<AdvancedDropdown
					id="country-options"
					value={country}
					// componentSize={ComponentSizeENUM.large}
					font={font}
					fullWidth={true}
					// options={countryList.options.map(op => ({ key: op.country_name, value: op.country_code }))}
					// dataLocale={dataLocale}
					// handleChange={e => setCountry(e.target.value)}
					onBlur={(val: string) => errorHandler("country", validateRequired, val)}
					placeholder={`${dataLocale.SELECT_COUNTRY}`}
					selectedValue={country}
					mainFontColor="#000"
					mainBackgroundColor="#fff"
					inputLabel={`${dataLocale.COUNTRY}*`}
					values={countryList.options.map(data => ({
						display: data.country_name,
						value: data.country_code,
						onChange: (e: any) => {
							onChangeCountry(
								e.target.value,
								false,
								country
							);
						},
					}))}
					disabled={desktopAddressFormConfig.country.disabled}
					isRTL={isRTL}
				/>
				{errors.country && <ErrorField>{errors.country}</ErrorField>}
			</div>
		)}</>;
	};

	const landmarkComponent = () => {
		return <>{desktopAddressFormConfig.landmark.isRendered && (
			<AddressInputField
				font={font}
				isFullWidth
				line={2}
				subText={(errors.landmark as string)}
				isError={!!errors.landmark}
				disabled={desktopAddressFormConfig.landmark.disabled}
				value={landmark}
				labelLeftGap={16}
				label={`${dataLocale.APARTMENT_ON_SIDE_OF_LIFT}`}

			>
				<LandmarkTextarea
					value={landmark}
					onChange={e => setLandmark(e.target.value)}
					placeholder=""
					font={font}
					disabled={desktopAddressFormConfig.landmark.disabled}
				/>
			</AddressInputField>)}</>;
	};


	const getComponent = (key: string) => {
		switch (key) {
		case "firstName":
			return firstNameComponent();
		case "lastName":
			return lastNameComponent();
		case "gender":
			return genderComponent();
		case "mobile":
			return mobileComponent();
		case "email":
			return emailComponent();
		case "addressLine1":
			return addressLine1Component();
		case "addressLine2":
			return addressLine2Component();
		case "zipcode":
			return zipcodeComponent();
		case "cityDistrict":
			return cityDistrictComponent();
		case "state":
			return stateComponent();
		case "country":
			return countryComponent();
		case "landmark":
			return landmarkComponent();
		default:
			return emptyComponent();
		}
	};

	return (
		<ReviewFormWrapper id={id} styleFont={font}>
			<Form onSubmit={submitForm}>

				{desktopAddressPlacementFormConfig.formPlacementConfig.map((obj: { firstComponent: string; secondComponent?: string; }, index: React.Key) => {
					return <InputWrapper key={index}>
						<>
							{getComponent(obj.firstComponent)}
							{obj?.secondComponent && getComponent(obj.secondComponent)}
						</>
					</InputWrapper>;
				})}
				{
					hasFrameProduct && InfoText && (
						<PowerCheckout><InfoCircle />{InfoText}</PowerCheckout>
					)
				}

				<div style={{ display: "flex", flexDirection: "column" }}>
					<AddressLabel>{`${dataLocale.SAVE_AS}*`}</AddressLabel>
					<div ref={addressLabelRef}>
						<AddressSwatch value={addressLabelTag} options={swatchOptions} onChange={(text) => onAddressLabelChange(text)} font={font} />
						{addressLabelTag === addressLabelENUM.OTHER && <AddressInputField font={font} subText={(errors.addressLabel as string)} isError={!!errors.addressLabel}>
							<AddressTextField isRTL={isRTL} value={addressLabel} onChange={e => setAddressLabel(e.target.value)} placeholder={dataLocale.ADDRESS_HEADING} clearText={() => setAddressLabel("")} onBlur={(e) => errorHandler("addressLabel", validateRequired, e.target.value)} />
						</AddressInputField>}
					</div>
					{addressLabelTag === addressLabelENUM.OTHER ? null : <SubText isError={!!errors.addressLabel}>{errors.addressLabel}</SubText>}
				</div>
				<ButtonsContainer btnVisible={btnVisible}>
					{/* <>{console.log(errors.isError,errors,"errors.isError......")}</> */}
					<InvisibleButton btnVisible={btnVisible} type="submit" disabled={!!errors.isError} ref={submitRef}>{dataLocale.ADD}</InvisibleButton>
					<InvisibleButton btnVisible={btnVisible} theme={ThemeENUM.secondary} type="submit" onClick={onCancel}>{dataLocale.CANCEL}</InvisibleButton>
				</ButtonsContainer>
			</Form>
		</ReviewFormWrapper>
	);
};

export { AddAddressForm };
