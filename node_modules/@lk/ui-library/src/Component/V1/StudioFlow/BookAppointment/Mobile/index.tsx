import React, { useEffect, useState } from "react";
import {
	DateDate,
	DateDay,
	DateItem,
	DateWrapper,
	Time,
	TimeItem,
	TimeValue,
} from "../Desktop/styles";
import { BookAppointmentStudioFlowType } from "../types";
import {
	AnimatedCheckContainer,
	BookAppointmentCTA,
	BookAppointmentCTAContainer,
	CTAWrapper,
	ConfirmAppointmentScreen,
	ConfirmHeading,
	Container,
	DateContainer,
	DateHeading,
	DateSubHeading,
	DatesWrapper,
	DottedLine,
	BookingDetails,
	Section,
	Row,
	RowItem,
	Heading,
	ParentContainer,
	StoreAddress,
	StoreDateSelector,
	StoreIcon,
	StoreName,
	StoreNameContainer,
	StoreTimeSelector,
	SubHeading,
	TimeContainer,
	TimeWrapper,
	PayNowCTAContainer,
	NoSlotsContainer,
	ErrorContainer,
} from "./styles";
import { getAMorPM, getTime, isToday } from "../helpers";
import { AnimatedCheck } from "../../../Auth";
import * as Icons from "../../../../../Icons";
import Spinner from "../../../../Common/Spinner";
import Toast from "../../../../Common/Toast";

const BookAppointmentMobile = ({
	localeData,
	showSuccessPage,
	// bookingCaptureDate,
	// bookedTime,
	bookingInfo,
	altStoreNameCatch,
	addressFull,
	paymentPending,
	handlePayNow,
	handleContinueShopping,
	isReschedule,
	error,
	refinedDateData,
	getMonth,
	selectedDate,
	selectedTime,
	bookSlotLoading,
	handleBookAppointment,
	bookAppointmentData,
	bookSlotData,
	handleSelectedTime,
	handleSelectedDate,
}: BookAppointmentStudioFlowType) => {

	const [hasAvailableSlots, setHasAvailableSlots] = useState(false);

	const {
		BOOK_APPOINTMENT,
		// CHOOSE_A_DATE,
		// WHEN_WILL_YOU_ARRIVE,
		// CONFIRM_APPOINTMENT,
		NO_SLOTS_AVAILABLE,
		TODAY,
		APPOINTMENT_CONFIRMED,
		BOOKED_ON,
		// APPOINTMENT_BOOKED_FOR,
		CONTINUE_SHOPPING,
		PAYMENT_PENDING,
		BLOCK_THE_PRODUCT,
		MSITE_PAY_NOW,
		DATE,
		TIME,
		SORRY_NO_SLOTS_AVAILABLE,
		PROCEED,
		ENCOUNTERED_BOOKING_ERROR
	} = localeData || {};

	const CANCEL = "CANCEL";
	const ACTIVE = "ACTIVE";

	const chip = ({
		type,
		/* mode = "", */ date = { date: "", day: "" },
		time = {
			isAvailable: 0,
			date: "",
			slotId: 0,
			startTime: "",
			endTime: "",
		},
		item = { isAvailable: 0, date: "" },
	}: {
		time?: {
			isAvailable?: number;
			date: any;
			slotId: number;
			startTime: string;
			endTime: string;
		};
		type?: number;
		date?: {
			date: string;
			day: any;
		};
		item?: {
			isAvailable?: number;
			date: any;
		};
		mode?: string;
	}) => {
		// const localmode = item.isAvailable === 0 && CANCEL;
		const isSelected = item?.date === selectedDate?.date && ACTIVE;
		const isTimeSelected =
			selectedTime &&
			time &&
			time.date === selectedDate.date &&
			time.slotId === selectedTime.slotId &&
			ACTIVE;
		const isTimeAvaialble = time?.isAvailable === 1 && CANCEL;
		switch (type) {
		case 1:
			return (
				<DateWrapper
					id="date-wrapper"
					onClick={() => {
						if (item.isAvailable === 0) return;
						handleSelectedDate(item);
						handleSelectedTime(null);
					}}
				>
					<DateItem id="date" isSelected={isSelected}>
						<DateDate id="date-date">
							{new Date(date?.date).getDate()}
						</DateDate>
						<DateDay id="date-day">
							{date?.day?.toString()?.slice(0, 3)}
						</DateDay>
						{isToday(new Date(date.date)) && <div>{TODAY}</div>}
					</DateItem>
				</DateWrapper>
			);
		case 2:
			return (
				<TimeItem
					id="time-item"
					isTimeSelected={isTimeSelected}
					isTimeAvaialble={isTimeAvaialble}
					onClick={() => {
						handleSelectedTime(time);
					}}
				>
					<Time id="time">
						<TimeValue>{getTime(time.startTime)}</TimeValue>
					</Time>
					<div> -</div>
					<Time id="time">
						<TimeValue>{getTime(time.endTime)}</TimeValue>
					</Time>
					<Time>
						<TimeValue className="day">{getAMorPM(time.endTime)}</TimeValue>
					</Time>
				</TimeItem>
			);
		default:
			return <></>;
		}
	};

	useEffect(() => {
		setHasAvailableSlots(checkAvailableSlots(selectedDate));
	}, [selectedDate]);


	function checkAvailableSlots(schedule: { timeSlot: { [x: string]: any; }; }) {
		for (const slotGroup in schedule?.timeSlot) {
			for (const slot of schedule.timeSlot[slotGroup]) {
				if (slot.isAvailable === 1) {
					return true;
				}
			}
		}
		return false;
	}

	return (
		<>
			{showSuccessPage && (
				<>
					<AnimatedCheckContainer>
						<AnimatedCheck />
					</AnimatedCheckContainer>
					<ConfirmAppointmentScreen id="confirm-appointment">
						<ConfirmHeading>{APPOINTMENT_CONFIRMED}</ConfirmHeading>
						<SubHeading>
							{BOOKED_ON} {bookingInfo?.date} {new Date().getFullYear()}
						</SubHeading>

						<BookingDetails id="booking-details">
							<Section id="section">
								<Row>
									<RowItem>
										<Icons.Slot />
										<div>
											<StoreName>
												{bookingInfo?.date} {new Date().getFullYear()}
											</StoreName>
											<StoreAddress>
												{bookingInfo?.time}
											</StoreAddress>
										</div>
									</RowItem>
								</Row>
								<DottedLine />
								<Row>
									<RowItem>
										<StoreIcon src="https://static1.lenskart.com/media/desktop/img/DesignStudioIcons/Store.svg" />
										<div>
											<StoreName>{altStoreNameCatch} </StoreName>
											<StoreAddress>{addressFull}</StoreAddress>
										</div>
									</RowItem>
								</Row>
								{paymentPending && (
									<Row>
										<RowItem id="row-item">
											<Icons.Dollar height="1.5em" width="1.5em" />
											<div>
												<StoreName alert={true}>{ PAYMENT_PENDING }</StoreName>
												<StoreAddress>
													{ BLOCK_THE_PRODUCT }
												</StoreAddress>
											</div>
										</RowItem>
									</Row>
								)}
							</Section>
							{paymentPending && (
								<PayNowCTAContainer onClick={() => handlePayNow()} primary={true}>
									<BookAppointmentCTA>{ MSITE_PAY_NOW }</BookAppointmentCTA>
								</PayNowCTAContainer>
							)}
							<PayNowCTAContainer
								onClick={() => handleContinueShopping()}
								primary={!paymentPending}
							>
								<BookAppointmentCTA>{CONTINUE_SHOPPING}</BookAppointmentCTA>
							</PayNowCTAContainer>
						</BookingDetails>
					</ConfirmAppointmentScreen>
				</>
			)}

			{!showSuccessPage && (
				<ParentContainer id="parent-container">
					{bookAppointmentData &&
						bookAppointmentData.error &&
						bookAppointmentData?.error?.isError && (
						<Toast
							text={bookAppointmentData?.error?.message}
							hideFn={() => {
								// setShowToast(false);
							}}
							timeOut={1000000000}
							width={"90%"}
							color="#FFEBEA"
							showIcon
							textColor="var(--dark-blue-100)"
							borderColor="1px solid #E34934"
							borderRadius="8px"
						/>
					)}
					{bookSlotData &&
						bookSlotData.error &&
						bookSlotData?.error?.isError && (
						<Toast
							text={bookSlotData?.error?.message}
							hideFn={() => {
								// setShowToast(false);
							}}
							timeOut={1000000000}
							width={"90%"}
							color="#FFEBEA"
							showIcon
							textColor="var(--dark-blue-100)"
							borderColor="1px solid #E34934"
							borderRadius="8px"
						/>
					)}

					<Heading>{!isReschedule
						? BOOK_APPOINTMENT?.toLowerCase()
						: "Reschedule your Appointment"}</Heading>
					{!error?.isError ? (
						<Container id="container">
							<StoreNameContainer id="store-name-container">
								<StoreName id="storename">
									<Icons.Check fill="#000042" />
									{altStoreNameCatch}
								</StoreName>
							</StoreNameContainer>
							<StoreDateSelector id="store-date-selector">
								<DateHeading>{ DATE }</DateHeading>
								{refinedDateData &&
									Object.keys(refinedDateData).map(
										(month: string, index: number) => (
											<DatesWrapper key={index} id="dates-wrapper">
												<DateSubHeading>
													{getMonth[parseInt(month)].slice(0, 3)}
												</DateSubHeading>
												<DateContainer id="date-container">
													{refinedDateData &&
														refinedDateData[month].map(
															(date: { date: any; day: any }) => {
																return chip({
																	type: 1,
																	item: date,
																	date: {
																		date: date.date,
																		day: date.day,
																	},
																});
															}
														)}
												</DateContainer>
											</DatesWrapper>
										)
									)}
							</StoreDateSelector>
							<StoreTimeSelector id="store-time-selector">
								<DateHeading>{ TIME }</DateHeading>
								{hasAvailableSlots ? (
									<TimeWrapper id="time-wrapper">
										<TimeContainer className="scrollable">
											{selectedDate?.timeSlot?.morning ||
												selectedDate?.timeSlot?.afternoon ||
												selectedDate?.timeSlot?.evening ? (
													<>
														{selectedDate?.timeSlot?.morning?.map(
															(slots: {
															isAvailable?: number;
															date?: any;
															slotId: number;
															startTime: string;
															endTime: string;
														}) => {
																return chip({
																	type: 2,
																	time: { ...slots, date: selectedDate.date },
																});
															}
														)}
														{selectedDate?.timeSlot?.afternoon?.map(
															(slots: {
															isAvailable?: number;
															date: any;
															slotId: number;
															startTime: string;
															endTime: string;
														}) => {
																return chip({
																	type: 2,
																	time: { ...slots, date: selectedDate.date },
																});
															}
														)}
														{selectedDate?.timeSlot?.evening?.map(
															(slots: {
															isAvailable?: number;
															date: any;
															slotId: number;
															startTime: string;
															endTime: string;
														}) => {
																return chip({
																	type: 2,
																	time: { ...slots, date: selectedDate.date },
																});
															}
														)}
														{selectedDate?.timeSlot?.night?.map(
															(slots: {
															isAvailable?: number;
															date: any;
															slotId: number;
															startTime: string;
															endTime: string;
														}) => {
																return chip({
																	type: 2,
																	time: { ...slots, date: selectedDate.date },
																});
															}
														)}
													</>
												) : (
													<span>{NO_SLOTS_AVAILABLE}</span>
												)}
										</TimeContainer>
									</TimeWrapper>
								) : (
									<NoSlotsContainer>
										<Icons.Sad height="2em" width="2em" />
										<SubHeading fontSize="10px">
											{ SORRY_NO_SLOTS_AVAILABLE }
										</SubHeading>
									</NoSlotsContainer>
								)}

							</StoreTimeSelector>
							<CTAWrapper>
								<BookAppointmentCTAContainer
									id="book appointment cta container"
									enabled={(selectedDate && selectedTime) || false}
									bookSlotLoading={bookSlotLoading}
									onClick={handleBookAppointment}
								>
									{!bookSlotLoading && (
										<BookAppointmentCTA>{ PROCEED }</BookAppointmentCTA>
									)}
									{!bookSlotLoading && <Icons.IconRight />}
									{bookSlotLoading && <Spinner show />}
								</BookAppointmentCTAContainer>
							</CTAWrapper>
						</Container>
					) : (
						<ErrorContainer>
							<NoSlotsContainer borderColor="#E34934" background="#FFEBEA">
								<Icons.Danger height="2em" width="2em" />
								<SubHeading fontSize="10px">
									{ ENCOUNTERED_BOOKING_ERROR }
								</SubHeading>
							</NoSlotsContainer>
						</ErrorContainer>
					)}
				</ParentContainer>
			)}
		</>
	);
};

export default BookAppointmentMobile;
