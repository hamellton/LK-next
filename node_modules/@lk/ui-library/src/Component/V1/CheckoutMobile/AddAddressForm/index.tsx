import React, { useEffect, useRef, useState } from "react";
import { TypographyENUM } from "../../../../Types/general";
import { AddressFormConfig, AddressFormType, SubmitType } from "./AddAddressForm.types";
import { Form, ReviewFormWrapper, AddressLabel, InvisibleButton, InputWrapper, FloatingInputError, FloatingInputWrapper, SubHeading, RadioLabel, SubTextUnitNumber, RadioContainer } from "./AddAddressForm.styles";
import AddressSwatch from "../../AddressSwatch";
import SvgOther from "../../../../Icons/Other";
import SvgWork from "../../../../Icons/Work";
import SvgHome from "../../../../Icons/Home";
import { SubText } from "../../AddressInputField/styles";
import { isName, validateEmail, validateNumber, validateRequired, getNumberLengthFromCode, validateUnitNumber, validateAddress } from "../../../../helpers";
import FloatingLabelInput from "../../../Common/FloatingLabelInput";
import { Radio } from "./Radio";
import { GenderText, LandmarkInfo } from "./styles";
import FloatingLabelDropdown from "../../../Common/FloatingLabelDropdown";
import GoogleLocationInput from "../../../Common/GoogleLocationInput";

enum addressLabelENUM {
	HOME = "Home",
	WORK = "Work",
	OTHER = "Other"
}
const AddAddressForm = ({
	id = "add-address-form",
	dataLocale = {
		FIRST_NAME: "First Name",
		LAST_NAME: "Last Name",
		MOBILE: "Mobile",
		EMAIL: "Email",
		ADDRESS_LINE_1: "Address Line 1",
		ADDRESS_LINE_2: "Address Line 2",
		ZIP_CODE: "Zip/Postal Code",
		CITY_DISTRICT: "City/District",
		COUNTRY: "Country",
		STATE_PROVINCE: "State/Province",
		CONTINUE: "CONTINUE",
		VIEW_SAVED_ADDRESS: "VIEW SAVED ADDRESS",
		MALE: "Male",
		FEMALE: "Female",
		ADDRESS_DETAILS: "Address details",
		SAVE_AS: "Save as",
		SELECT_GENDER: "Select Gender",
		LANDMARK: "Landmark",
		ADD: "ADD",
		SYMBOL_ASTRIX: "*",
		ONLY_NUMBERS_ALLOWED: "Only Numbers Allowed.",
	},
	font = TypographyENUM.defaultBook,
	onSubmit = () => console.log("submit"),
	// onViewSaved = () => console.log("View Saved Address"),
	// onPincodeChanged = (pin) => console.log("Fetch status of Pincode", pin),
	// countryList = {
	// 	options: [],
	// 	optionsText: "",
	// 	optionValue: ""
	// },
	// stateList = {
	// 	options: [],
	// 	optionsText: "",
	// 	optionValue: ""
	// },
	// isReturnExchange = false,
	initialAddressData = null,
	userEmail,
	userNumber,
	getPincodeData,
	phoneCode,
	submitRef,
	btnVisible,
	tempAddressData,
	updateTempAddressData,
	isRTL = false,
	// SHIPPING_ADDRESS_FORM_CONFIG,
	// redirection,
	configData,
	countryList = {
		options: [],
		optionsText: "",
		optionValue: ""
	},
	checkoutAsGuest = false,
	currCountry = ""
}: AddressFormType) => {
	const initialCountry = countryList.options.length > 0 ? countryList.options[0].country_code : "";
	const [firstName, setFirstName] = useState(initialAddressData?.firstName || tempAddressData?.firstName || "");
	const [lastName, setLastName] = useState(initialAddressData?.lastName || tempAddressData?.lastName || tempAddressData?.lastName || "");
	const [mobile, setMobile] = useState(initialAddressData?.phone || userNumber || tempAddressData?.mobile || "");
	const [email, setEmail] = useState(initialAddressData?.email || userEmail || tempAddressData?.email || "");
	const [addressLine1, setAddressLine1] = useState(initialAddressData?.addressline1 || tempAddressData?.addressLine1 || "");
	const [addressLine2, setAddressLine2] = useState(initialAddressData?.addressline2 || tempAddressData?.addressLine2 || "");
	// const addressLine2 = initialAddressData?.addressline2 || tempAddressData?.addressLine2 || "";
	const [zipCode, setZipCode] = useState(initialAddressData?.postcode || tempAddressData?.zipCode || "");
	const [addressLabel, setAddressLabel] = useState(initialAddressData?.addressLabel || tempAddressData?.addressLabel || "");
	const [addressLabelTag, setAddressLabelTag] = useState(initialAddressData?.addressLabel ? (initialAddressData?.addressLabel === addressLabelENUM.HOME ? addressLabelENUM.HOME : (initialAddressData?.addressLabel === addressLabelENUM.WORK ? addressLabelENUM.WORK : (initialAddressData?.addressLabel ? addressLabelENUM.OTHER : ""))) : (tempAddressData?.addressLabel === addressLabelENUM.HOME ? addressLabelENUM.HOME : (tempAddressData?.addressLabel === addressLabelENUM.WORK ? addressLabelENUM.WORK : (tempAddressData?.addressLabel ? addressLabelENUM.OTHER : ""))));
	const [landmark, setLandmark] = useState(initialAddressData?.landmark || tempAddressData?.landmark || "");
	// const [showOtherAddressLabel, setShowOtherAddressLabel] = useState(false);
	const [cityDistrict, setCityDistrict] = useState(initialAddressData?.city || tempAddressData?.cityDistrict || "");
	const [country, setCountry] = useState(initialAddressData?.country || initialAddressData?.lkCountry || tempAddressData?.country || currCountry || initialCountry ||"");
	console.log(initialAddressData?.country, initialAddressData?.lkCountry, tempAddressData?.country, currCountry, initialCountry, country, countryList, "Oi countries");
	const [state, setState] = useState(initialAddressData?.state || tempAddressData?.state || "");
	const [currentPhoneCode, setCurrentPhoneCode] = useState(initialAddressData?.phoneCode || phoneCode || tempAddressData?.currentPhoneCode || "+91");
	const [gender, setGender] = useState(initialAddressData?.gender || tempAddressData?.gender || "");
	// const isRTL = false;
	const addressLabelRef = useRef<HTMLDivElement>(null);
	const [resetInput, setResetInput] = useState(false);

	const { SHIPPING_ADDRESS_FORM_CONFIG, PINCODE_LENGTH = 6, VALIDATE_PINCODE = true, MOBILE_ADDRESS_FORM_PLACEMENT_CONFIG } = configData;
	const addressFormConfig: AddressFormConfig = SHIPPING_ADDRESS_FORM_CONFIG && JSON.parse(SHIPPING_ADDRESS_FORM_CONFIG);
	const mobileAddressPlacementFormConfig = MOBILE_ADDRESS_FORM_PLACEMENT_CONFIG && JSON.parse(MOBILE_ADDRESS_FORM_PLACEMENT_CONFIG);
	const [alphanumericPincode, setAlphaNumericPincode] = useState(false);
	const [errors, setErrors] = useState<{ [name: string]: string | boolean }>({
		// isError: false,
		firstName: "", //
		lastName: "",
		mobile: "", // +ph
		email: "", // +em
		addressLine1: "", //
		addressLine2: "",
		zipCode: "", // +pin
		addressLabel: "", //
		landmark: "",
		cityDistrict: "", // +should be valid as per pincode api
		country: "", // +should be valid as per pincode api
		state: "", // +should be valid as per pincode api
		currentPhoneCode: "", //
		gender: ""
	});

	const phoneCodeConfig = typeof configData?.AVAILABLE_NEIGHBOUR_COUNTRIES === "string"
		? JSON.parse(configData?.AVAILABLE_NEIGHBOUR_COUNTRIES)
		: configData?.AVAILABLE_NEIGHBOUR_COUNTRIES;


	//* set alphanumeric pincode for 'ca'
	useEffect(() => {
		// setZipCode(""); //* resetting zip code on country change as alphanumeric pincodes are not validated on api end for countries with pincode as number
		if(country === "ca"){
			setAlphaNumericPincode(true);
		}else{
			setAlphaNumericPincode(false);
		}
	}, [country]);

	// const [swatchValue, setSwatchValue] = useState("Home");
	const submitForm = (e: React.FormEvent<HTMLFormElement>) => {
		e.preventDefault();
		// addressStepX 1
		if (validateAll()) {
			onSubmit(initialAddressData && initialAddressData.id ? SubmitType.edit : SubmitType.add, initialAddressData && initialAddressData.id ? initialAddressData.id : null, initialAddressData && initialAddressData.id ? { firstName: firstName, lastName: lastName, phone: mobile, email: email, addressline1: addressLine1, addressline2: addressLine2, postcode: zipCode || "000000", city: country === "SG" ? state : cityDistrict, state: state, country: country, id: initialAddressData.id, addressLabel, landmark, phoneCode: currentPhoneCode, gender } : { firstName: firstName, lastName: lastName, phone: mobile, email: email, addressline1: addressLine1, addressline2: addressLine2, postcode: zipCode, city: country.toUpperCase() === "SG" ? country : cityDistrict, state: country.toUpperCase() === "SG" ? country : state, country: country, addressLabel, landmark, phoneCode: currentPhoneCode, gender });
		}
	};

	// function onChangeCountry(country: string, cartCall = true, prevCountry: string) {
	// 	if (country && country !== prevCountry) {
	// 		if (country === "SG") {
	// 			setCountry(country);
	// 			setCityDistrict("Singapore");
	// 			setState("Singapore");
	// 		}
	// 		else {
	// 			setCountry(country);
	// 			// setCityDistrict("");
	// 			// setState("");
	// 		}
	// 		if (country === "IN") {
	// 			// getPincodeData(zipCode)
	// 			// 	.then(data => console.log(data))
	// 			// 	.catch(err => console.log(err));
	// 		}
	// 		if (cartCall && !isReturnExchange) {
	// 			// countryShippingCheck(country);
	// 		}
	// 	}
	// }

	useEffect(() => {
		return () => {
			updateTempAddressData({
				firstName: "",
				lastName: "",
				mobile: "",
				email: "",
				addressLine1: "",
				addressLine2: "",
				zipCode: "",
				addressLabel: "",
				landmark: "",
				cityDistrict: "",
				country: "",
				state: "",
				currentPhoneCode: "",
				gender: ""
			});
		};
	}, []);

	useEffect(() => {
		// On submit the prev state of the current input chaged was shown. For this reason we have commented return statement. Now the the updates are made on each character added in input fields.
		// return () => {
		// console.log("Update temp address data called");


		updateTempAddressData({ firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict, country, state, currentPhoneCode, gender });
		// storeTempAddressData({ firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict: "", country: "", state: "", currentPhoneCode: "", gender }, guestEmail, guestNumber);
		//only store once there is a change in value
		//delete on address submit
		//delete on add new address click
		//delete on user credentials change
		//delete after 5mins
		//if guest info exists, user can move forward from login to address
		//store guestNumber/guestEmail along with this and check if once coming back to this page, the same creds are there, if so
		//read this and pass it to this component in props
		// };
	}, [firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict, country, state, currentPhoneCode, gender]);

	function onFetchPincode(pin?: string) {
		// let isError = false;
		// isError = isError ||
		const currentPin = pin || zipCode;
		errorHandler("zipCode", validateRequired, pin || zipCode);
		if(VALIDATE_PINCODE) {
			if(currentPin && currentPin !== "000000") getPincodeData(pin || zipCode)
				.then(data => {
					console.log(data, "data");
					if (data?.isError) {
						// setErrors(err => ({ ...err, zipCode: data.message }));
						// setCountry("");
						// setCityDistrict("");
						setState("");
						// isError = true;
					}
					else if (data?.canDeliver) {
						setCountry(data.country);
						setCityDistrict(data.city);
						setState(data.state);
						setErrors(err => ({ ...err, zipCode: "", cityDistrict: "", state: "", country: "" }));
					}
				})
				.catch(err => {
					// isError = true;
					console.log(err, "Error");
				});
		}
	}
	const swatchOptions = [{ icon: <SvgHome />, text: addressLabelENUM.HOME }, { icon: <SvgWork />, text: addressLabelENUM.WORK }, {
		icon:
			<SvgOther />, text: addressLabelENUM.OTHER
	}];

	function onAddressLabelChange(label: string) {
		if (addressLabelTag === label) {
			//
		} else if (label === addressLabelENUM.OTHER) {
			setAddressLabel("");
			setAddressLabelTag(label);
			// errorHandler("addressLabel", validateRequired, "");
		} else {
			setAddressLabel(label);
			setAddressLabelTag(label);
			setErrors(err => ({ ...err, addressLabel: "" }));
		}
	}

	// const hasErrors = (errors: {[name: string]: boolean}) => {
	// 	Object.keys(errors).filter(err => err !== "isError").forEach(err => {
	// 		if(errors[err]) return true;
	// 	});
	// 	if(!(firstName && mobile && email && addressLine1 && zipCode && addressLabel && cityDistrict && country && state)) return true;
	// 	if(!validateEmail())
	// 	return false;
	// };
	// const [fieldSwitch, setFieldSwitch] = useState(false);
	function errorHandler(key: string, cb: (...props: any) => string | boolean, ...val: any) {
		// setFieldSwitch(f => !f);
		const error = cb(...val);
		// const newErrors = { ...errors };
		// setErrors(err => ({ ...err, err[key]: error, isError: !!error }));
		// newErrors[key] = error;
		// newErrors.isError = !!error;
		// console.log("newErrors", error, val, cb);
		setErrors(errors => {
			const newErrors = { ...errors };
			newErrors[key] = error;
			// newErrors.isError = !!error;
			return newErrors;
		});
		return !!error;
	}

	// useEffect(() => {
	// 	if(disableAction && typeof disableAction === "function") disableAction(!!errors.isError);
	// 	console.log(errors);
	// }, [errors.isError, disableAction, fieldSwitch]);

	// function containsOnlyNumbers(str : string) {
	// 	return /^[0-9]+$/.test(str);
	// }

	useEffect(() => {
		if (zipCode.length === 6 && VALIDATE_PINCODE) {
			// setErrors(err => ({ ...err, zipCode: "" }));
			onFetchPincode(zipCode);
		}
	}, [zipCode]);


	// // * if user previous enter character pincode for 'ca' and then switch to 'us', setting error
	// useEffect(() => {
	// 	if(!alphanumericPincode && !containsOnlyNumbers(zipCode) && zipCode !== ""){
	// 		setErrors({ ...errors, zipCode: dataLocale?.ONLY_NUMBERS_ALLOWED || "Only Numbers Allowed" });
	// 	}else{
	// 		setErrors({ ...errors, zipCode: "" });
	// 	}
	// }, [zipCode, country, alphanumericPincode]);

	// useEffect(() => {
	// 	return () => {
	// 		console.log("Update temp address data called");
	// 		console.log({ firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict, country, state, currentPhoneCode, gender });
	// 		// storeTempAddressData({ firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict: "", country: "", state: "", currentPhoneCode: "", gender }, guestEmail, guestNumber);
	// 		//only store once there is a change in value
	// 		//delete on address submit
	// 		//delete on add new address click
	// 		//delete on user credentials change
	// 		//delete after 5mins
	// 		//if guest info exists, user can move forward from login to address
	// 		//store guestNumber/guestEmail along with this and check if once coming back to this page, the same creds are there, if so
	// 		//read this and pass it to this component in props
	// 	};
	// }, [firstName, lastName, mobile, email, addressLine1, addressLine2, zipCode, addressLabel, landmark, cityDistrict, country, state, currentPhoneCode, gender]);


	// console.log({ addressLabel, addressLabelTag, labelerr: errors.addressLabel }, "addresslabel =================");
	// console.log(addressFormConfig);
	function validateAll() {
		let isError = false;
		isError = addressFormConfig?.firstName?.rendered && errorHandler("firstName", isName, firstName) || isError;
		isError = addressFormConfig?.lastName?.rendered && errorHandler("lastName", isName, lastName) || isError;
		isError = addressFormConfig?.mobile?.rendered && errorHandler("mobile", validateRequired, mobile) || isError;
		isError = addressFormConfig?.mobile?.rendered && errorHandler("mobile", validateNumber, mobile, currentPhoneCode) || isError;
		isError = addressFormConfig?.gender?.rendered && errorHandler("gender", validateRequired, gender) || isError;
		isError = addressFormConfig?.email?.rendered && errorHandler("email", validateRequired, email) || isError;
		isError = addressFormConfig?.email?.rendered && errorHandler("email", validateEmail, email) || isError;
		isError = addressFormConfig?.addressLine1?.rendered && errorHandler("addressLine1", validateRequired, addressLine1) || isError;
		isError = addressFormConfig?.addressLine2?.rendered && errorHandler("addressLine2", validateRequired, addressLine2) || isError;
		isError = addressFormConfig?.googleLocationInput?.rendered && errorHandler("addressLine2", validateUnitNumber, addressLine2) || isError;
		isError = addressFormConfig?.cityDistrict?.rendered && errorHandler("cityDistrict", validateRequired, cityDistrict) || isError;
		isError = addressFormConfig?.state?.rendered && errorHandler("state", validateRequired, state) || isError;
		isError = addressFormConfig?.country?.rendered && errorHandler("country", validateRequired, country) || isError;
		isError = addressFormConfig?.zipcode?.rendered && country!=="AE" && country!=="ae" && errorHandler("zipCode", validateRequired, zipCode) || isError;
		isError = addressFormConfig?.addressLabel?.rendered && configData?.SAVE_AS_FIELD_REQUIRED && errorHandler("addressLabel", validateRequired, addressLabel) || isError;
		// onFetchPincode(zipCode);
		// Object.values(errors).forEach(err => {
		// 	if(err) isError = true;
		// });
		if (isError && errorHandler("addressLabel", validateRequired, addressLabel) && addressLabelRef.current) addressLabelRef.current?.scrollIntoView();
		return !isError;
	}

	const firstNameComponent = () => {
		return <>{
			addressFormConfig?.firstName?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} label={`${dataLocale?.FIRST_NAME} ${dataLocale?.SYMBOL_ASTRIX}`} initialValue={firstName} type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setFirstName} handleError={(e) => errorHandler("firstName", isName, e.target.value)} ></FloatingLabelInput>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.firstName}</FloatingInputError>
				</FloatingInputWrapper>

			)
		}</>;
	};

	const lastNameComponent = () => {
		return <>{
			addressFormConfig?.lastName?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} label={`${dataLocale?.LAST_NAME} ${dataLocale?.SYMBOL_ASTRIX}`} initialValue={lastName} type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setLastName} handleError={(e) => errorHandler("lastName", isName, e.target.value)}></FloatingLabelInput>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.lastName}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const genderComponent = () => {

		return <>{
			addressFormConfig?.gender?.rendered && (
				<FloatingInputWrapper>
					<RadioLabel font={TypographyENUM.lkSansRegular} >{`${dataLocale?.SELECT_GENDER} ${dataLocale?.SYMBOL_ASTRIX}`}</RadioLabel>
					<InputWrapper>
						{mobileAddressPlacementFormConfig.genderConfig.map((config: { key: React.SetStateAction<string>; label: string | number | boolean | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactFragment | React.ReactPortal | null | undefined; }, idx: number) => {
							return (
								<RadioContainer key={idx}>
									<Radio
										isSelected={gender === config.key}
										onClick={() => {
											setGender(config.key);
											errors.gender = "";
										}}
									/>
									<GenderText isRTL={isRTL}>{config.label}</GenderText>
								</RadioContainer>
							);
						})}
					</InputWrapper>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.gender}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const mobileComponent = () => {
		return <>{
			addressFormConfig?.mobile?.rendered && (
				<FloatingInputWrapper>
					<InputWrapper>
						<FloatingLabelInput showSvgArrow={true} msiteAddressPage={true} isRTL={isRTL} label={`${dataLocale?.MOBILE_NUMBER} ${dataLocale?.SYMBOL_ASTRIX}`} availableCountries={phoneCodeConfig?.availableCountries} maxLength={getNumberLengthFromCode(currentPhoneCode)} isNumberOnly={true} initialValue={mobile} type="tel" width="100%" countryCodePrefix={currentPhoneCode} setCurrentPhoneCode={setCurrentPhoneCode} font={TypographyENUM.lkSansRegular} getInputValue={setMobile} handleError={(e) => errorHandler("mobile", validateNumber, e.target.value, currentPhoneCode)}></FloatingLabelInput>
					</InputWrapper>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.mobile}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const emailComponent = () => {
		return <>{
			addressFormConfig?.email?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} label={`${dataLocale?.EMAIL} ${dataLocale?.SYMBOL_ASTRIX}`} initialValue={email} type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setEmail} handleError={(e) => errorHandler("email", validateEmail, e.target.value)}></FloatingLabelInput>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.email}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};


	const subHeader = () => {
		return <SubHeading font={TypographyENUM.lkSansRegular}>

			{/* {redirection ? dataLocale.YOUR : dataLocale.SHIPPING}{dataLocale?.ADDRESS_DETAILS} */}
			{dataLocale?.ADDRESS_DETAILS_SUBHEADER_TEXT}
		</SubHeading>;
	};
	const addressLine1Component = () => {
		return <>{
			addressFormConfig?.addressLine1?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} label={`${dataLocale?.ADDRESS_LINE_1} ${dataLocale?.SYMBOL_ASTRIX}`} initialValue={addressLine1} type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setAddressLine1} handleError={(e) => errorHandler("addressLine1", validateRequired, e.target.value)}></FloatingLabelInput>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.addressLine1}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const addressLine2Component = () => {
		return <>{
			addressFormConfig?.addressLine2?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} disabled={addressFormConfig?.addressLine2?.disabled} label={dataLocale?.ADDRESS_LINE_2} initialValue={addressLine2} type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setAddressLine2} handleError={(e) => errorHandler("addressLine2", dataLocale?.ADDRESS_LINE_2!=="Unit Number*"?validateAddress:validateUnitNumber, e.target.value)}></FloatingLabelInput>
					{!checkoutAsGuest && errors.addressLine2?<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.addressLine2 } </FloatingInputError>:<SubTextUnitNumber>{dataLocale.ADDRESSLINE2_SUB_TEXT}</SubTextUnitNumber>}
				</FloatingInputWrapper>
			)
		}</>;
	};

	const geoLocationComponent = () => {
		return <>{
			addressFormConfig?.googleLocationInput?.rendered && (
				<FloatingInputWrapper>
					<GoogleLocationInput disabled={addressFormConfig?.googleLocationInput?.disabled} handleError={(e) => errorHandler("addressLine2", validateRequired, e.target.value)} configData={configData} callback={setAddressLine2} initialValue={addressLine2} label={"Search for your location *"} />
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.addressLine2}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const zipcodeComponent = () => {
		return <>{
			country.toLowerCase()!=="ae" && currentPhoneCode !== "+971" && addressFormConfig?.zipcode?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} disabled={addressFormConfig?.zipcode?.disabled} label={`${dataLocale?.ZIP_CODE} ${dataLocale?.SYMBOL_ASTRIX}`} initialValue={zipCode} isNumberOnly={!alphanumericPincode} maxLength={PINCODE_LENGTH} type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setZipCode} resetInput={resetInput} setResetInput={setResetInput} handleError={(e) => onFetchPincode(e.target.value)} />
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.zipCode}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const landmarkComponent = () => {
		return <>{
			addressFormConfig?.landmark?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput isRTL={isRTL} disabled={addressFormConfig?.landmark?.disabled} label={dataLocale?.LANDMARK} type="text" width="100%" font={TypographyENUM.lkSansRegular} initialValue={landmark} getInputValue={setLandmark}></FloatingLabelInput>
					<LandmarkInfo>{dataLocale?.LANDMARK_INFO_TEXT}</LandmarkInfo>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.landmark}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const cityDistrictComponent = () => {
		return <>{
			addressFormConfig?.cityDistrict?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput noSpecialChar isRTL={isRTL} disabled={addressFormConfig?.cityDistrict?.disabled} label={`${dataLocale?.CITY_DISTRICT} ${dataLocale?.SYMBOL_ASTRIX}`} type="text" width="100%" font={TypographyENUM.lkSansRegular} initialValue={cityDistrict} getInputValue={setCityDistrict} handleError={(e) => errorHandler("cityDistrict", validateRequired, e.target.value)}></FloatingLabelInput>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.cityDistrict}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const stateComponent = () => {
		return <>{
			addressFormConfig?.state?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelInput noSpecialChar isRTL={isRTL} disabled={addressFormConfig?.state?.disabled} label={`${dataLocale?.STATE_PROVINCE} ${dataLocale?.SYMBOL_ASTRIX}`} type="text" width="100%" font={TypographyENUM.lkSansRegular} initialValue={state} getInputValue={setState} handleError={(e) => errorHandler("state", validateRequired, e.target.value)}></FloatingLabelInput>
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.state}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const countryComponent = () => {
		return <>{
			addressFormConfig?.country?.rendered && (
				<FloatingInputWrapper>
					<FloatingLabelDropdown disabled={addressFormConfig?.country?.disabled} label={`${dataLocale?.COUNTRY} ${dataLocale?.SYMBOL_ASTRIX}`} font={TypographyENUM.lkSansRegular} options={countryList.options} value={country} getInputValue={(val) => {setCountry(val); setResetInput(true); setZipCode("");}}></FloatingLabelDropdown>
					{/* <FloatingLabelInput label="Country" type="text" width="100%" font={TypographyENUM.lkSansRegular} getInputValue={setLandmark}></FloatingLabelInput> */}
					<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.country}</FloatingInputError>
				</FloatingInputWrapper>
			)
		}</>;
	};

	const getComponent = (key: string) => {
		switch (key) {
		case "firstName":
			return firstNameComponent();
		case "lastName":
			return lastNameComponent();
		case "gender":
			return genderComponent();
		case "mobile":
			return mobileComponent();
		case "email":
			return emailComponent();
		case "addressLine1":
			return addressLine1Component();
		case "addressLine2":
			return addressLine2Component();
		case "zipcode":
			return zipcodeComponent();
		case "cityDistrict":
			return cityDistrictComponent();
		case "state":
			return stateComponent();
		case "country":
			return countryComponent();
		case "landmark":
			return landmarkComponent();
		case "subHeader":
			return subHeader();
		case "geoLocation":
			return geoLocationComponent();
		}
	};

	return (
		<ReviewFormWrapper id={id} styleFont={font}>
			<Form onSubmit={submitForm}>

				{mobileAddressPlacementFormConfig.formPlacementConfig.map((obj: { firstComponent: string; }, index: React.Key) => {
					return <FloatingInputWrapper key={index}>
						<>
							{getComponent(obj.firstComponent)}

						</>
					</FloatingInputWrapper>;
				})}

				{
					addressFormConfig?.addressLabel?.rendered && (
						<div style={{ display: "flex", flexDirection: "column", width: "100%" }}>
							<AddressLabel>{`${dataLocale.SAVE_AS}${dataLocale?.SYMBOL_ASTRIX}`}</AddressLabel>
							<div ref={addressLabelRef}>
								<AddressSwatch value={addressLabelTag} options={swatchOptions} onChange={(text) => onAddressLabelChange(text)} font={font} />
								{addressLabelTag === addressLabelENUM.OTHER && (
									<FloatingInputWrapper>
										<FloatingLabelInput isRTL={isRTL} font={TypographyENUM.lkSansRegular} getInputValue={setAddressLabel} label={dataLocale?.ADDRESS_HEADING} initialValue={addressLabel} type="text" width="100%" handleError={(e) => errorHandler("addressLabel", validateRequired, e.target.value)} ></FloatingLabelInput>
										<FloatingInputError font={TypographyENUM.lkSansRegular} >{errors.addressLabel}</FloatingInputError>
									</FloatingInputWrapper>
								)
								}
							</div>
							{addressLabelTag === addressLabelENUM.OTHER ? null : <SubText isError={!!errors.addressLabel}>{errors.addressLabel}</SubText>}
						</div>
					)
				}

				<InvisibleButton btnVisible={btnVisible} type="submit" disabled={!!errors.isError} ref={submitRef}>{dataLocale?.ADD}</InvisibleButton>
			</Form>
		</ReviewFormWrapper>
	);
};

export { AddAddressForm };
