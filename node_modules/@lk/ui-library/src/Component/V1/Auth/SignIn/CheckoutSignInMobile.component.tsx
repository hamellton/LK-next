import React, { useEffect, useState, useRef, useCallback, Fragment } from "react";
import EditField, { EditBtn } from "../components/EditField";
import { InputFieldContainer } from "../components/InputFieldContainer";
// import SignIn, { Spacer } from "../components/SignIn";
import SignIn, { Spacer } from "../components/SignIn";
import SignInHead from "../components/SignInHead";
import { TextField } from "../components/TextField";
import Button from "../../Button";
import OtpField from "../components/OtpField";
import { Captcha, CheckoutSigninContainer, FlexCenter, WhatsAppText, MobileBottomButtonSection, PhoneCodeDropdownWrapper } from "./styles";
import { SignInType, kindENUM, ThemeENUM, TypographyENUM, TextTypeENUM } from "../../../../Types/general";
import { SignInFormType } from "./SignIn.types";
import { SelectField } from "../components/SelectField";
import SampleDiv from "./SampleDiv";
import { getNumberLengthFromCode, validateEmail, validateNumber } from "../../../../helpers";
import usePrevious from "./usePrevious";
import ForgotPasswordMobile from "./ForgotPasswordMobile";
import PhoneCodeDropdown from "../../PhonecodeDropdown";
// import usePrevious from "./usePrevious";

const CheckoutSignInMobile = ({
	id,
	dataLocale,
	font,
	onProceed,
	resetSignInStatus,
	signInStatus,
	onClose,
	guestCheckout,
	countryCode,
	signInImgLink,
	showHome = false,
	setGetWhatsAppUpdate,
	isCaptchaRequired,
	isCaptchaVerified,
	resetCaptcha,
	renderCaptcha,
	scriptLoaded,
	recaptchaInDom,
	setRecaptchaInDom,
	forgotPassCallback,
	redirectToHome,
	otpSent,
	setCaptcha,
	resetCaptchaVerified,
	isMobileView=false,
	// isRTL = false
	isRTL = false,
	resetServerError,
	showWhatsAppOption = false,
	phoneCodeConfigData,
	supportMultipleCountries,
	incCountryCodeFont
}: SignInFormType) => {
	const [inputValue, setInputValue] = useState<string | number>("");
	const [showOTP, setShowOTP] = useState(false);
	const [showPassword, setShowPassword] = useState(false);
	const [passwordField, setPasswordField] = useState<string | null>(null);
	const [submit, setSubmit] = useState(false);
	const [error, setError] = useState("");
	const [timer, setTimer] = useState(30);
	// const [isMobileField, setIsMobileField] = useState(true);
	const timerRef = useRef<ReturnType<typeof setInterval>>();
	const [showForgotPassword, setShowForgotPassword] = useState(false);
	const [isCaptchaMounted, setisCaptchaMounted] = useState(false);
	const [inputFocusedOut, setInputFocused] = useState(false);

	const [stayInPassword,setStayInPassword] = useState(false);
	const [currentPhoneCode, setCurrentPhoneCode] = useState(countryCode);
	// let prevIsCaptchaRequired = usePrevious(isCaptchaRequired);
	// const [isCaptchaVerified, setIsCaptchaVerified] = useState(false);
	// const [captchaResponse, setCaptchaResponse] = useState(null);

	// useEffect(() => {
	// 	if (isCaptchaRequired) {
	// 	  prevIsCaptchaRequired = true;
	// 	}
	// }, []);
	const prevOTPSent = usePrevious(otpSent);
	const prevRecaptchaInDom = usePrevious(recaptchaInDom);
	// const prevUser = usePrevious(user);
	// const prevoTPLoginSuccess = usePrevious(oTPLoginSuccess);
	// const prevUserInputValidate = usePrevious(userInputValidate);

	useEffect(() => {
		if(resetSignInStatus) {
			resetSignInStatus();
			setShowPassword(false);
			setStayInPassword(false);
			setPasswordField(null);
			setSubmit(false);
			setError("");
			setTimer(30);
			setShowOTP(false);
			setInputValue("");
		}
		if (isCaptchaRequired) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect1", "\n");
			// prevIsCaptchaRequired = true;
			renderCaptcha();
		}
		return () => {
			if(typeof setRecaptchaInDom === "function") setRecaptchaInDom(false);
		};
	}, []);
	// useEffect(() => {
	// 	if (isCaptchaRequired) {
	// 		prevIsCaptchaRequired = true;
	// 	}
	// }, []);
	useEffect(() => {
		// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 ", { prevIsCaptchaRequired, isCaptchaRequired, scriptLoaded, showOTP, recaptchaInDom, isCaptchaVerified, isCaptchaMounted, prevOTPSent, otpSent, setCaptcha }, "\n");
		// console.log({ isCaptchaRequired, scriptLoaded, showOTP, recaptchaInDom, isCaptchaVerified, prevOTPSent, otpSent, setCaptcha, prevRecaptchaInDom });
		// console.log({ prevOTPSent, otpSent });
		if (
			// prevIsCaptchaRequired !== undefined &&
			// prevIsCaptchaRequired !== isCaptchaRequired &&
			isCaptchaRequired
			&& (scriptLoaded && showOTP) && recaptchaInDom && !isCaptchaVerified
			&& !isCaptchaMounted
		) {
		// if(isCaptchaRequired && (scriptLoaded && showOTP) && recaptchaInDom && !isCaptchaMounted) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 if", "\n");
			setisCaptchaMounted(true);
			renderCaptcha();
		} else if (
			// prevIsCaptchaRequired === isCaptchaRequired &&
			isCaptchaRequired &&
			isCaptchaVerified &&
			recaptchaInDom &&
			scriptLoaded
			// &&
			// otpSent
			// &&
			// otpSent
			&& prevOTPSent !== otpSent
		) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 else if 1", "\n");
			resetCaptcha();
			// setisCaptchaMounted(true);
		} else if (
			// prevIsCaptchaRequired !== isCaptchaRequired &&
			recaptchaInDom &&
			!isCaptchaRequired &&
			scriptLoaded &&
			typeof setCaptcha === "function"
		) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 else if 2", "\n");
			setCaptcha(null);
		}
		// else {
		// 	setRecaptchaInDom(false);
		// }
	}, [isCaptchaRequired, scriptLoaded, recaptchaInDom, setCaptcha, isCaptchaVerified]);

	useEffect(() => {
		if(isCaptchaRequired && (scriptLoaded && showOTP) && isCaptchaVerified && recaptchaInDom && !prevRecaptchaInDom && otpSent === prevOTPSent && typeof resetCaptchaVerified === "function") {
			resetCaptchaVerified();
		}
	}, [isCaptchaRequired, isCaptchaVerified, recaptchaInDom, otpSent, resetCaptchaVerified]);

	// useEffect(() => {
	// 	if (isCaptchaRequired) {
	// 		renderCaptcha();
	// 	}
	// }, []);
	// useEffect(() => {
	// 	if(isCaptchaMounted && !isCaptchaRequired && recaptchaInDom){
	// 		console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect3 ");
	// 		resetCaptcha();
	// 		// setisCaptchaMounted(true);
	// 	}
	// }, [isCaptchaMounted, isCaptchaRequired]);

	useEffect(() => {
		if (signInStatus?.showOTP) setShowOTP(signInStatus.showOTP);
		if (signInStatus?.showPassword){
			setShowPassword(signInStatus.showPassword);
			signInStatus.showPassword ? setStayInPassword(true) : setStayInPassword(false);
		}
	}, [signInStatus, signInStatus?.showOTP, signInStatus?.showPassword]);

	const [fieldType, setFieldType] = React.useState<SignInType>(SignInType.PHONE);
	// const updateValue = (type: string, value: string) => {
	// 	setInputValue(value);
	// };

	const updatePasswordValue = (val: string | number) => {
		setPasswordField(typeof val === "string" ? val : val.toString());
		setSubmit(true);
	};


	const clickHandler = () => {
		// console.log(submit && passwordField ? 1 : 2, "clickHandler");
		if(resetSignInStatus) resetSignInStatus();
		if (submit && passwordField) {
			// data.captchaKey = captchaResponse; //validateOtp api key
			// data.occurence = occurence; //Resend
			onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), passwordField), supportMultipleCountries ? currentPhoneCode : undefined;
			setSubmit(false);
			setPasswordField(null);
			setShowOTP(false);
			setShowPassword(false);
			setStayInPassword(true);
		} else {
			onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), undefined, supportMultipleCountries ? currentPhoneCode : undefined);
		}
	};

	// const guestCheckout = () => {
	// 	//
	// };
	const autoSubmitOTP = useCallback(() => {
		if (submit && passwordField) {
			if (isCaptchaRequired && !isCaptchaVerified) return;
			if(resetSignInStatus) resetSignInStatus();
			setError("");
			onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), passwordField);
			setSubmit(false);
			setPasswordField(null);
			// setShowOTP(false);
			setShowPassword(false);
			setStayInPassword(false);
		}
	}
	,[onProceed, fieldType, inputValue, passwordField, setSubmit, setPasswordField, setShowOTP, setStayInPassword , setShowPassword, submit, isCaptchaRequired, isCaptchaVerified]);

	function resendOTP() {
		onProceed(SignInType.PHONE, typeof inputValue === "string" ? inputValue : inputValue.toString(), undefined , supportMultipleCountries ? currentPhoneCode : undefined);
	}

	// const verifyCaptchaCallback = response => {
	// 	if (response.length !== 0) {
	// 	  setIsCaptchaVerified(true);
	// 	  setCaptchaResponse(response);
	// 	}
	//   };

	//   const resetCaptcha = () => {
	// 	window.grecaptcha.reset();
	// 	setIsCaptchaVerified(false);
	// 	setCaptchaResponse(null);
	//   };

	//   const renderCaptcha = () => {
	// 	// setCaptchaRendered(true);
	// 	// if (window && !window.grecaptcha) {
	// 	window.grecaptcha.render("recaptcha", {
	// 	  sitekey: config.siteKey,
	// 	  theme: "light",
	// 	  callback: verifyCaptchaCallback,
	// 	  "expired-callback": resetCaptcha,
	// 	});
	// 	setIsCaptchaVerified(false);
	// 	// }
	//   };
	//   // * mount changes
	//   useEffect(() => {
	// 	// if (registerActions) {
	// 	registerActions.resetAuthData();
	// 	if (isCaptchaRequired) {
	// 	  renderCaptcha();
	// 	}
	// 	// }
	//   }, []);

	//   const setCaptcha = response => {
	// 	setCaptchaResponse(response);
	//   };
	//   useEffect(() => {
	// 	if (
	// 	  prevIsCaptchaRequired !== undefined &&
	// 	  prevIsCaptchaRequired !== isCaptchaRequired &&
	// 	  isCaptchaRequired
	// 	) {
	// 	  renderCaptcha();
	// 	} else if (
	// 	  prevIsCaptchaRequired === isCaptchaRequired &&
	// 	  isCaptchaRequired &&
	// 	  isCaptchaVerified &&
	// 	  prevOTPSent !== oTPSent
	// 	) {
	// 	  resetCaptcha();
	// 	} else if (prevIsCaptchaRequired !== isCaptchaRequired && !isCaptchaRequired) {
	// 	  setCaptcha(null);
	// 	}
	//   }, [isCaptchaRequired, oTPSent, prevIsCaptchaRequired]);


	// const getUpdateOnWhatsapp = (event: React.ChangeEvent<HTMLInputElement>) => {
	// 	action("get update on whatsapp")(event, { getUpdateOnWhatsapp:event.target.checked });
	// };

	// const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {
	// 	console.log("working");
	// 	event.preventDefault();
	// };
	function validateErrors(e: any, cb: (...props: any) => void) {
		let error = "";
		if (!showOTP && !showPassword) {
			if (fieldType === SignInType.PHONE) {
				error = validateNumber(inputValue, countryCode);
			} else if (fieldType === SignInType.EMAIL) {
				error = validateEmail(inputValue);
			}
		} else if (!showOTP && showPassword) {
			if (!passwordField) error = "Please Enter a value";
		} else if (showOTP) {
			if (!passwordField || passwordField.toString().split("").length !== 4) error = "Please enter a correct OTP";
		}
		setError(error);
		console.log(error, "Error");
		if (!error) cb(e);
	}
	const onKeyUpHandler = (e: React.ChangeEvent<HTMLInputElement>) => {
		if (e.target.value.length === 0) {
			// setFieldType(SignInType.EMAIL);
		} else if (isNaN(Number(e.target.value))) {
			// setFieldType(SignInType.EMAIL);
		} else {
			// setFieldType(SignInType.PHONE);
		}
	};

	const handleBackClick = () => {
		setShowOTP(false);
		setShowPassword(false);
		setStayInPassword(false);
	};

	const startTimer = () => {
		setTimer(30);
		timerRef.current = setInterval(() => {
			setTimer((time: number) => {
				if (time === 0) {
					clearInterval(timerRef.current);
					return 0;
				}
				else return time - 1;
			});
		}, 1000);
	};
	useEffect(() => {
		if (showOTP) startTimer();
	}, [showOTP]);

	useEffect(() => {
		if(!showOTP && !showPassword){
			if(isCaptchaVerified && typeof resetCaptchaVerified === "function") {
				// resetCaptchaVerified();
			}
			setPasswordField(null);
		}
	}, [showOTP, showPassword]);
	// }, [showOTP, showPassword]);

	// useEffect(() => {
	// 	setRecaptchaInDom(true);
	// }, []);


	function changeInputValue(e: any) {
		setInputValue(e.target.value);
		if (!showOTP && !showPassword && inputFocusedOut) {
			let error = "";
			if (fieldType === SignInType.PHONE) {
				error = validateNumber(e.target.value, countryCode);
			} else if (fieldType === SignInType.EMAIL) {
				error = validateEmail(e.target.value);
			}
			setError(error);
		}
	}
	useEffect(() => {
		setInputFocused(false);
		if(typeof resetServerError === "function") resetServerError();
	}, [showOTP, showPassword, fieldType]);

	// const submitRef = useRef<HTMLElement>();


	return showForgotPassword ? (
		<ForgotPasswordMobile
			signInImgLink={signInImgLink}
			isRTL={isRTL}
			dataLocale={dataLocale}
			apiCallback={forgotPassCallback}
			redirectToHome={redirectToHome}
			validateEmail={validateEmail}
			hideHandler={() => setShowForgotPassword(false)}
			isMobileView={isMobileView}
		/>
	) : (
		<>
			<SignIn isRTL={isRTL} onClose={() => { setError(""); onClose(); }} signInImgLink="" id={id} font={font} showHome={showHome} isMobileView={isMobileView}>
				{showOTP && <CheckoutSigninContainer isMobileView={isMobileView}>
					<SignInHead signInText={dataLocale.SIGN_IN_SIGN_UP} isRTL={isRTL} />
					<EditField dataLocale={dataLocale} onEdit={handleBackClick} label={dataLocale.ENTER_ONE_TIME_PASSWORD_SENT_TO} mainText={`${countryCode} ${typeof inputValue === "string" ? inputValue : inputValue.toString()}`} disabled={signInStatus.isLoading} isMobileView={isMobileView}/>

					{/* {signInStatus.isLoading ? <InlineLoader alt="Loading..." src={loaderImageLink} /> : <> */}

					{!signInStatus.isLoading && <><InputFieldContainer otpField={true} isFullWidth={true} isError={Boolean(error || (signInStatus.isError && signInStatus.errorMessage))} subText={error || (signInStatus.isError && signInStatus.errorMessage ? signInStatus.errorMessage : "")} isBoundary={false}>
						<OtpField value={passwordField} onChange={val => updatePasswordValue(val)} type={TextTypeENUM.number} showText={true} autoSubmitOTP={autoSubmitOTP}/>
					</InputFieldContainer><div>{timer === 0 ? <><EditBtn disabled={timer !== 0 || (!isCaptchaVerified && isCaptchaRequired)} onClick={() => { startTimer(); resendOTP(); }}>{dataLocale.RESEND_OTP} </EditBtn> <EditBtn onClick={() => guestCheckout?.({ email: "", number: inputValue.toString() })}>Skip</EditBtn></> : <span><b>Resend OTP</b> in {`00:${timer.toString().length > 1 ? timer : `0${timer}`}`} sec</span>}</div><Spacer isMobileView={isMobileView} /></>}
					{/* {(isCaptchaRequired) &&
						<Captcha>
							<div id="recaptcha">{!recaptchaInDom && setRecaptchaInDom ? <>{setRecaptchaInDom(true)}</> : null}</div>
						</Captcha>} */}
					{(isCaptchaRequired) &&
						<Captcha>
							<div id="recaptcha"></div>
							<SampleDiv setRecaptchaInDom={setRecaptchaInDom} setisCaptchaMounted={setisCaptchaMounted}/>
						</Captcha>}
					{/* {(isCaptchaRequired && !isCaptchaVerified) && <Verify disabled={!isCaptchaVerified && isCaptchaRequired} onClick={()=>{
							onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), undefined, supportMultipleCountries ? currentPhoneCode : undefined);
						}}>Verify</Verify>} */}

					{showWhatsAppOption && isCaptchaVerified && <SelectField setGetsAppUpdate={setGetWhatsAppUpdate}><FlexCenter><WhatsAppText>{dataLocale.GET_UPDATES_ON_WHATSAPP || "Get updates on Whatsapp"} </WhatsAppText><img width={25} src="https://static.lenskart.com/media/desktop/img/25-July-19/whatsapp.png" alt="Whatsapp"/></FlexCenter></SelectField>}
					<MobileBottomButtonSection>
						<Button
							id="remove-button"
							theme={ThemeENUM.primary}
							kind={kindENUM.background}
							showChildren={true}
							font={TypographyENUM.lkSansRegular} //onDecreaseItem(item.id)
							width="100"
							disabled={isCaptchaMounted}
							onClick={(e: any) => validateErrors(e, clickHandler)}
							loading={signInStatus.isLoading}
						>
							{signInStatus.isLoading ? "" : dataLocale.PROCEED}
						</Button>
						<Spacer isMobileView={isMobileView}/>
						{/* <EditBtn disabled={signInStatus.isLoading || isCaptchaMounted} fullWidth onClick={(e: any) => validateErrors(e, guestCheckout ? () => guestCheckout({ email: fieldType === SignInType.PHONE ? "" : inputValue.toString(), number: fieldType === SignInType.EMAIL ? null : inputValue.toString() }) : () => null)}>{dataLocale?.CHECKOUT_AS_GUEST}</EditBtn> */}
					</MobileBottomButtonSection>

				</CheckoutSigninContainer>}


				{((!showOTP && showPassword) || (stayInPassword)) && <CheckoutSigninContainer isMobileView={isMobileView}>
					<SignInHead signInText={dataLocale?.SIGN_IN_SIGN_UP} isRTL={isRTL} />
					<EditField dataLocale={dataLocale} onEdit={handleBackClick} label={dataLocale.ENTER_PASSWORD_FOR} mainText={typeof inputValue === "string" ? inputValue : inputValue.toString()} />
					<InputFieldContainer isFullWidth={true} isError={Boolean(error || (signInStatus.isError && signInStatus.errorMessage))} subText={error || (signInStatus.isError && signInStatus.errorMessage ? signInStatus.errorMessage : "")} isMobileView={isMobileView}>
						<TextField isRTL={isRTL} value={passwordField} type="password" onChange={(e) => updatePasswordValue(e.target.value)} placeholder="Password" onKeyUpChange={() => null}></TextField>
					</InputFieldContainer>
					<div><EditBtn onClick={() => setShowForgotPassword(true)}>{dataLocale.FORGOT_PASSWORD}</EditBtn></div>
					<Spacer isMobileView={isMobileView}/>

					<MobileBottomButtonSection>
						<Button
							id="remove-button"
							theme={ThemeENUM.primary}
							kind={kindENUM.background}
							showChildren={true}
							font={TypographyENUM.lkSansRegular}
							width="100"
							onClick={(e: any) => validateErrors(e, clickHandler)}
							loading={signInStatus.isLoading}
						>
							{signInStatus.isLoading ? "" : dataLocale.PROCEED}
						</Button>

						<Spacer isMobileView={isMobileView}/>
						{/* {<EditBtn fullWidth disabled={signInStatus.isLoading} onClick={(e: any) => validateErrors(e, guestCheckout ? () => guestCheckout({ email: fieldType === SignInType.PHONE ? "" : inputValue.toString(), number: fieldType === SignInType.EMAIL ? null : inputValue.toString() }) : () => null)}>{dataLocale?.CHECKOUT_AS_GUEST}</EditBtn>} */}
					</MobileBottomButtonSection>
				</CheckoutSigninContainer>}


				<CheckoutSigninContainer isMobileView={isMobileView}>
					{!showOTP && !showPassword && (!stayInPassword) && <>
						<SignInHead signInText={dataLocale.SIGN_IN_SIGN_UP} isRTL={isRTL} />
						<InputFieldContainer forceLTR={isRTL && fieldType === SignInType.PHONE} isFullWidth={true} isError={Boolean(error || (signInStatus.isError && signInStatus.errorMessage))} subText={error || (signInStatus.isError && signInStatus.errorMessage ? signInStatus.errorMessage : "")} isMobileView={isMobileView}>
							{fieldType === SignInType.PHONE && phoneCodeConfigData && supportMultipleCountries && <PhoneCodeDropdownWrapper top={incCountryCodeFont ? "0" : "2"}><PhoneCodeDropdown isMobileView={isMobileView} showSvgArrow = {true} incCountryCodeFont={incCountryCodeFont} availableCountries={phoneCodeConfigData.availableCountries} currentPhoneCode={currentPhoneCode} onChange={(newPhoneCode: string) => setCurrentPhoneCode(newPhoneCode)} /></PhoneCodeDropdownWrapper>}
							{fieldType === SignInType.PHONE ? <TextField isRTL={isRTL} value={typeof inputValue === "string" ? inputValue : inputValue.toString()} type={TextTypeENUM.text} onChange={changeInputValue} placeholder={dataLocale?.MOBILE} onKeyUpChange={onKeyUpHandler} onBlur={(e) => {validateErrors(e, () => null); setInputFocused(true);}} maxLength={getNumberLengthFromCode(countryCode)} onKeyPress={(event: any) => {
								const keycode = event.which;
								if (
									!(
										event.shiftKey === false &&
											(keycode === 46 ||
												keycode === 8 ||
												keycode === 37 ||
												keycode === 39 ||
												(keycode >= 48 && keycode <= 57))
									)
								) {
									event.preventDefault();
								}
							}}>
								{fieldType === SignInType.PHONE && !supportMultipleCountries ? countryCode : ""}
							</TextField> : <TextField value={typeof inputValue === "string" ? inputValue : inputValue.toString()} type={TextTypeENUM.text} onChange={changeInputValue} onBlur={(e) => {validateErrors(e, () => null); setInputFocused(true);}} placeholder={dataLocale?.EMAIL} onKeyUpChange={onKeyUpHandler} maxLength={100}>
							</TextField>}
						</InputFieldContainer>
						{/* {signInStatus.isLoading ? <InlineLoader alt="Loading..." src="//static.lenskart.com/skin/frontend/base/default/images/loader2.gif" /> : <Button */}
						{showHome && showWhatsAppOption && <SelectField setGetsAppUpdate={setGetWhatsAppUpdate}><FlexCenter><WhatsAppText>{dataLocale.GET_UPDATES_ON_WHATSAPP || "Get updates on Whatsapp"} </WhatsAppText><img width={25} src="https://static.lenskart.com/media/desktop/img/25-July-19/whatsapp.png" alt="Whatsapp"/></FlexCenter></SelectField>}

						<MobileBottomButtonSection>
							<Button
								id="remove-button"
								theme={ThemeENUM.primary}
								kind={kindENUM.background}
								showChildren={true}
								font={TypographyENUM.lkSansRegular} //onDecreaseItem(item.id)
								width="100"
								disabled={signInStatus.isLoading}
								onClick={(e: any) => validateErrors(e, clickHandler)}
								loading={signInStatus.isLoading}
								// ref={submitRef}
							>
								{signInStatus.isLoading ? "" : dataLocale.SIGN_IN_SIGN_UP}
							</Button>
							<Spacer isMobileView={isMobileView}/>
							<Button
								id="remove-button"
								theme={ThemeENUM.secondary}
								kind={kindENUM.border}
								showChildren={true}
								font={TypographyENUM.lkSansRegular} //onDecreaseItem(item.id)
								width="100"
								disabled={signInStatus.isLoading}
								onClick={() => {
									setFieldType(fieldType => fieldType === SignInType.EMAIL ? SignInType.PHONE : SignInType.EMAIL);
									setInputValue("");
									setError("");
									if(typeof resetSignInStatus === "function") resetSignInStatus();
								}}
							>
								{fieldType === SignInType.PHONE ? dataLocale.USE_EMAIL_ADDRESS : dataLocale.USE_MOBILE_NUMBER}
							</Button>

							<Spacer isMobileView={isMobileView}/>
							<EditBtn fullWidth disabled={fieldType !== SignInType.PHONE || !inputValue || signInStatus.isLoading || isCaptchaMounted} onClick={(e: any) => validateErrors(e, guestCheckout ? () => guestCheckout({ email: fieldType === SignInType.PHONE ? "" : inputValue.toString(), number: fieldType === SignInType.EMAIL ? null : inputValue.toString() }) : () => null)}>{dataLocale?.CHECKOUT_AS_GUEST}</EditBtn>

						</MobileBottomButtonSection>
					</>
					}
				</CheckoutSigninContainer>
			</SignIn>
		</>
	);
};

export { CheckoutSignInMobile };
