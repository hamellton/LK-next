import React, { useEffect, useState, useRef, useCallback, Fragment } from "react";
import EditField, { EditBtn } from "../components/EditField";
import { InputFieldContainer } from "../components/InputFieldContainer";
// import SignIn, { Spacer } from "../components/SignIn";
import SignIn, { Spacer } from "../components/SignIn";
import SignInHead from "../components/SignInHead";
import { TextField } from "../components/TextField";
import Button from "../../Button";
import OtpField from "../components/OtpField";
import { Captcha, CheckoutSigninContainer, FlexCenter, InfoText, InlineLoader, PhoneCodeDropdownWrapper, ResendOtpText, Verify, WhatsAppText } from "./styles";
import { SignInType, kindENUM, ThemeENUM, TypographyENUM, TextTypeENUM, DeviceTypes } from "../../../../Types/general";
import { SignInFormType } from "./SignIn.types";
import { SelectField } from "../components/SelectField";
import SampleDiv from "./SampleDiv";
import ForgotPassword from "./ForgotPassword";
import { getNumberLengthFromCode, validateEmail, validateNumber } from "../../../../helpers";
import usePrevious from "./usePrevious";
import PhoneCodeDropdown from "../../PhonecodeDropdown";
// import usePrevious from "./usePrevious";

const CheckoutSignIn = ({
	id,
	dataLocale,
	font,
	onProceed,
	resetSignInStatus,
	signInStatus,
	onClose,
	moveToSignUp,
	guestCheckout,
	countryCode,
	signInImgLink,
	loaderImageLink,
	showHome = false,
	showWhatsAppOption = false,
	setGetWhatsAppUpdate,
	isCaptchaRequired,
	isCaptchaVerified,
	resetCaptcha,
	renderCaptcha,
	scriptLoaded,
	recaptchaInDom,
	setRecaptchaInDom,
	forgotPassCallback,
	redirectToHome,
	otpSent,
	setCaptcha,
	resetCaptchaVerified,
	isHome,
	isMobileCart,
	// isRTL = false
	isRTL = false,
	showGuestFlow = true,
	onSignIn,
	isSignIn,
	OtpTime=30,
	msiteForgotPassword = false,
	resetServerError,
	negativeMargin=false,
	homeGuestFlow = true,
	phoneCodeConfigData,
	supportMultipleCountries,
	incCountryCodeFont,
	deviceType
}: SignInFormType) => {
	const [inputValue, setInputValue] = useState<string | number>("");
	const [showOTP, setShowOTP] = useState(false);
	const [showPassword, setShowPassword] = useState(false);
	const [passwordField, setPasswordField] = useState<string | null>(null);
	const [submit, setSubmit] = useState(false);
	const [error, setError] = useState("");
	const [timer, setTimer] = useState(OtpTime);
	const [ showOtpSentMsg, setShowOtpSentMsg]= useState(false);
	// const [isMobileField, setIsMobileField] = useState(true);
	const timerRef = useRef<ReturnType<typeof setInterval>>();
	const [showForgotPassword, setShowForgotPassword] = useState(false);
	const [isCaptchaMounted, setisCaptchaMounted] = useState(false);
	const [inputFocusedOut, setInputFocused] = useState(false);
	const prevOTPSent = usePrevious(otpSent);
	const prevRecaptchaInDom = usePrevious(recaptchaInDom);
	const [currentPhoneCode, setCurrentPhoneCode] = useState(countryCode);
	const [whatsappUpdate, setWhatsappUpdate] = useState(false);
	const isMobileView = deviceType === DeviceTypes.MOBILE;

	if(isSignIn) {
		onSignIn();
	}

	useEffect(() => {
		if(resetSignInStatus) {
			resetSignInStatus();
			setShowPassword(false);
			setPasswordField(null);
			setSubmit(false);
			setError("");
			setTimer(OtpTime);
			setShowOTP(false);
			setInputValue("");
		}
		if (isCaptchaRequired && recaptchaInDom) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect1", "\n");
			// prevIsCaptchaRequired = true;
			renderCaptcha();
		}
		return () => {
			if(typeof setRecaptchaInDom === "function") setRecaptchaInDom(false);
		};
	}, []);
	// useEffect(() => {
	// 	if (isCaptchaRequired) {
	// 		prevIsCaptchaRequired = true;
	// 	}
	// }, []);
	useEffect(() => {
		// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 ", { prevIsCaptchaRequired, isCaptchaRequired, scriptLoaded, showOTP, recaptchaInDom, isCaptchaVerified, isCaptchaMounted, prevOTPSent, otpSent, setCaptcha }, "\n");
		// console.log({ isCaptchaRequired, scriptLoaded, showOTP, recaptchaInDom, isCaptchaVerified, prevOTPSent, otpSent, setCaptcha, prevRecaptchaInDom });
		// console.log({ prevOTPSent, otpSent });
		if (
			// prevIsCaptchaRequired !== undefined &&
			// prevIsCaptchaRequired !== isCaptchaRequired &&
			isCaptchaRequired
			&& (scriptLoaded && showOTP) && recaptchaInDom && !isCaptchaVerified
			&& !isCaptchaMounted
		) {
			// if(isCaptchaRequired && (scriptLoaded && showOTP) && recaptchaInDom && !isCaptchaMounted) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 if", "\n");
			setisCaptchaMounted(true);
			renderCaptcha();
		} else if (
			// prevIsCaptchaRequired === isCaptchaRequired &&
			isCaptchaRequired &&
			isCaptchaVerified &&
			recaptchaInDom &&
			scriptLoaded
			// &&
			// otpSent
			// &&
			// otpSent
			&& prevOTPSent !== otpSent
		) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 else if 1", "\n");
			resetCaptcha();
			// setisCaptchaMounted(true);
		} else if (
			// prevIsCaptchaRequired !== isCaptchaRequired &&
			recaptchaInDom &&
			!isCaptchaRequired &&
			scriptLoaded &&
			typeof setCaptcha === "function"
		) {
			// console.log("Captcha $$$$$$$$$$$$$$$$$$", "useEffect2 else if 2", "\n");
			setCaptcha(null);
		}
		// else {
		// 	setRecaptchaInDom(false);
		// }
	}, [isCaptchaRequired, scriptLoaded, recaptchaInDom, setCaptcha, isCaptchaVerified]);

	useEffect(() => {
		if(isCaptchaRequired && (scriptLoaded && showOTP) && isCaptchaVerified && recaptchaInDom && !prevRecaptchaInDom && otpSent === prevOTPSent && typeof resetCaptchaVerified === "function") {
			resetCaptchaVerified();
		}
	}, [isCaptchaRequired, isCaptchaVerified, recaptchaInDom, otpSent, resetCaptchaVerified]);

	useEffect(() => {
		if (signInStatus?.showOTP) setShowOTP(signInStatus.showOTP);
		if (signInStatus?.showPassword) setShowPassword(signInStatus.showPassword);
	}, [signInStatus, signInStatus?.showOTP, signInStatus?.showPassword]);

	const [fieldType, setFieldType] = React.useState<SignInType>(SignInType.PHONE);
	// const updateValue = (type: string, value: string) => {
	// 	setInputValue(value);
	// };

	const updatePasswordValue = (val: string | number) => {
		setPasswordField(typeof val === "string" ? val : val.toString());
		setSubmit(true);
	};


	const clickHandler = () => {
		// console.log(submit && passwordField ? 1 : 2, "clickHandler");
		if(resetSignInStatus) resetSignInStatus();
		if (submit && passwordField) {
			// data.captchaKey = captchaResponse; //validateOtp api key
			// data.occurence = occurence; //Resend
			onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), passwordField, supportMultipleCountries ? currentPhoneCode : undefined);
			// setSubmit(false);
			// setPasswordField(null);
			// setShowOTP(false);
			// setShowPassword(false);
		} else {
			onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), undefined, supportMultipleCountries ? currentPhoneCode : undefined);
		}
	};

	// const guestCheckout = () => {
	// 	//
	// };
	const autoSubmitOTP = useCallback(() => {
		if (submit && passwordField && !isCaptchaVerified) {
			if (isCaptchaRequired && !isCaptchaVerified) return;
			if(resetSignInStatus) resetSignInStatus();
			setError("");
			onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), passwordField);
			setSubmit(false);
			setPasswordField(null);
			// setShowOTP(false);
			setShowPassword(false);
		}
	}
	,[onProceed, fieldType, inputValue, passwordField, setSubmit, setPasswordField, setShowOTP, setShowPassword, submit, isCaptchaRequired, isCaptchaVerified]);

	function resendOTP() {
		setShowOtpSentMsg(true);
		onProceed(SignInType.PHONE, typeof inputValue === "string" ? inputValue : inputValue.toString(), undefined , supportMultipleCountries ? currentPhoneCode : undefined);
	}

	// const verifyCaptchaCallback = response => {
	// 	if (response.length !== 0) {
	// 	  setIsCaptchaVerified(true);
	// 	  setCaptchaResponse(response);
	// 	}
	//   };

	//   const resetCaptcha = () => {
	// 	window.grecaptcha.reset();
	// 	setIsCaptchaVerified(false);
	// 	setCaptchaResponse(null);
	//   };

	//   const renderCaptcha = () => {
	// 	// setCaptchaRendered(true);
	// 	// if (window && !window.grecaptcha) {
	// 	window.grecaptcha.render("recaptcha", {
	// 	  sitekey: config.siteKey,
	// 	  theme: "light",
	// 	  callback: verifyCaptchaCallback,
	// 	  "expired-callback": resetCaptcha,
	// 	});
	// 	setIsCaptchaVerified(false);
	// 	// }
	//   };
	//   // * mount changes
	//   useEffect(() => {
	// 	// if (registerActions) {
	// 	registerActions.resetAuthData();
	// 	if (isCaptchaRequired) {
	// 	  renderCaptcha();
	// 	}
	// 	// }
	//   }, []);

	//   const setCaptcha = response => {
	// 	setCaptchaResponse(response);
	//   };
	//   useEffect(() => {
	// 	if (
	// 	  prevIsCaptchaRequired !== undefined &&
	// 	  prevIsCaptchaRequired !== isCaptchaRequired &&
	// 	  isCaptchaRequired
	// 	) {
	// 	  renderCaptcha();
	// 	} else if (
	// 	  prevIsCaptchaRequired === isCaptchaRequired &&
	// 	  isCaptchaRequired &&
	// 	  isCaptchaVerified &&
	// 	  prevOTPSent !== oTPSent
	// 	) {
	// 	  resetCaptcha();
	// 	} else if (prevIsCaptchaRequired !== isCaptchaRequired && !isCaptchaRequired) {
	// 	  setCaptcha(null);
	// 	}
	//   }, [isCaptchaRequired, oTPSent, prevIsCaptchaRequired]);


	// const getUpdateOnWhatsapp = (event: React.ChangeEvent<HTMLInputElement>) => {
	// 	action("get update on whatsapp")(event, { getUpdateOnWhatsapp:event.target.checked });
	// };

	// const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {
	// 	console.log("working");
	// 	event.preventDefault();
	// };
	function validateErrors(e: any, cb: (...props: any) => void) {
		let error = "";
		if (!showOTP && !showPassword) {
			if (fieldType === SignInType.PHONE) {
				error = validateNumber(inputValue, countryCode,undefined, dataLocale, true);
			} else if (fieldType === SignInType.EMAIL) {
				error = validateEmail(inputValue, dataLocale, false);
			}
		} else if (!showOTP && showPassword) {
			if (!passwordField) error = "Please Enter a value";
		} else if (showOTP) {
			if (!passwordField || passwordField.toString().split("").length !== 4) error = "Please enter a correct OTP";
		}
		setError(error);
		console.log(error, "Error");
		if (!error) cb(e);
	}
	// const onKeyUpHandler = (e: React.ChangeEvent<HTMLInputElement>) => {
	// 	if (e.target.value.length === 0) {
	// 		// setFieldType(SignInType.EMAIL);
	// 	} else if (isNaN(Number(e.target.value))) {
	// 		// setFieldType(SignInType.EMAIL);
	// 	} else {
	// 		// setFieldType(SignInType.PHONE);
	// 	}
	// };

	const onKeyUpHandler = (e: any) => {
		if (e.target.value.length === 0 || isNaN(Number(e.target.value)) || e.target.value.length > getNumberLengthFromCode(countryCode)) {
			if(e.target.value === "" || validateEmail(e.target.value, dataLocale, true) || (!isCaptchaVerified && isCaptchaRequired)) return;
		}
		else {
			if(e.target.value === "" || validateNumber(e.target.value, countryCode, undefined, dataLocale, true) || (!isCaptchaVerified && isCaptchaRequired)) return;
		}
		e.preventDefault();

		if (e.keyCode === 13) {
			validateErrors(e, clickHandler);
		}
	};

	const handleBackClick = () => {
		if(typeof resetSignInStatus === "function") resetSignInStatus();
		setShowOTP(false);
		setShowPassword(false);
	};

	const startTimer = () => {
		setTimer(OtpTime);
		clearInterval(timerRef.current); //added so that there will be no previous interval before starting a new interval
		timerRef.current = setInterval(() => {
			setTimer((time: number) => {
				if (time === 0) {
					clearInterval(timerRef.current);
					return 0;
				}
				else return time - 1;
			});
		}, 1000);
	};
	useEffect(() => {
		if (showOTP) startTimer();
	}, [showOTP]);

	useEffect(() => {
		if(!showOTP && !showPassword){
			if(isCaptchaVerified && typeof resetCaptchaVerified === "function") {
				// resetCaptchaVerified();
			}
			setPasswordField(null);
		}
	}, [showOTP, showPassword]);
	// }, [showOTP, showPassword]);

	// useEffect(() => {
	// 	setRecaptchaInDom(true);
	// }, []);


	function changeInputValue(e: any) {
		setInputValue(e.target.value);
		if (!showOTP && !showPassword && inputFocusedOut) {
			let error = "";
			if (fieldType === SignInType.PHONE) {
				error = validateNumber(e.target.value, countryCode, undefined, dataLocale, true);
			} else if (fieldType === SignInType.EMAIL) {
				error = validateEmail(e.target.value, dataLocale, true);
			}
			setError(error);
		}
	}
	useEffect(() => {
		setInputFocused(false);
		if(typeof resetServerError === "function") resetServerError();
	}, [showOTP, showPassword, fieldType]);

	const validateOtp = (otp: string) => {
		const numCheck = (/^[0-9]+$/);
		if(otp && otp.length === 4 && numCheck.test(otp)) {
			return "";
		} else {
			return "Incorrect otp";
		}
	};
	const handleKeyUpOnInput = (e: any) => {
		if(showPassword && !showOTP) {
			if(e.target.value === "" || (!isCaptchaVerified && isCaptchaRequired)) return;
		} else if(showOTP) {
			if(e.target.value === "" || validateOtp(e.target.value) || (!isCaptchaVerified && isCaptchaRequired)) return;
		}
		e.preventDefault();

		if (e.keyCode === 13) {
			validateErrors(e, clickHandler);
		}
	};
	// console.log(isCaptchaRequired,"isCaptchaRequired.......");

	return showForgotPassword ? <ForgotPassword
		negativeMargin={negativeMargin}
		signInImgLink={signInImgLink}
		msiteForgotPassword={msiteForgotPassword}
		onClose={onClose}
		dataLocale={dataLocale}
		apiCallback={forgotPassCallback}
		redirectToHome={redirectToHome}
		validateEmail={validateEmail}
		hideHandler={(reset?: boolean) => {
			setShowForgotPassword(false);
			if (reset) setShowPassword(false);
		}}
		isRTL={isRTL}
	/> : (
		<>
			<SignIn isRTL={isRTL} onClose={() => { setError(""); onClose(); }} signInImgLink={signInImgLink} id={id} font={font} showHome={showHome}>
				{showOTP && <CheckoutSigninContainer>
					<SignInHead signInText={!isMobileCart ? ""/*dataLocale?.ENTER_ONE_TIME_PASSWORD_SENT_TO*/ : dataLocale.En} isRTL={isRTL} />
					<EditField isCheckout isOtpField={deviceType === "mobilesite" ? false : true} dataLocale={dataLocale} onEdit={handleBackClick} label={dataLocale.ENTER_ONE_TIME_PASSWORD_SENT_TO} mainText={`${countryCode} ${typeof inputValue === "string" ? inputValue : inputValue.toString()}`} newMainText={true} textVal = {`${typeof inputValue === "string" ? inputValue : inputValue.toString()}`} countryCode = {countryCode} isRTL={isRTL} disabled={signInStatus.isLoading} />
					{signInStatus.isLoading ? <InlineLoader alt="Loading..." src={loaderImageLink} /> : <>
						<InputFieldContainer isCheckout otpField={true} isFullWidth={true} isError={Boolean(error || (signInStatus.isError && signInStatus.errorMessage))} subText={error || (signInStatus.isError && signInStatus.errorMessage ? signInStatus.errorMessage : "")} isBoundary={false}>
							<OtpField isCheckout value={passwordField} onChange={val => updatePasswordValue(val)} type={TextTypeENUM.number} showText={true} autoSubmitOTP={autoSubmitOTP} onKeyUpChange={handleKeyUpOnInput} />
						</InputFieldContainer>
						<div className="otp-sent">{timer === 0 ? <><EditBtn disabled={timer !== 0 || (!isCaptchaVerified && isCaptchaRequired)} onClick={() => { startTimer(); resendOTP(); }} style={{ marginRight: "20px" }}>{dataLocale.RESEND_OTP}</EditBtn> </> : <ResendOtpText><b>{dataLocale.RESEND_OTP_IN} {`00:${timer.toString().length > 1 ? timer : `0${timer}`}`} {dataLocale.SEC}</b>  {showOtpSentMsg && <><br/> {dataLocale.OTP_HAS_BEEN_SENT_SUCCESSFULLY} </>} </ResendOtpText>} <>{!timer && <EditBtn onClick={() => guestCheckout?.({ email: "", number: inputValue.toString() })}>{dataLocale.SKIP}</EditBtn>}</></div>
						<Spacer isOtpField={true} style={{ height:"25px" }} />
						{/* {(isCaptchaRequired) &&
						<Captcha>
							<div id="recaptcha">{!recaptchaInDom && setRecaptchaInDom ? <>{setRecaptchaInDom(true)}</> : null}</div>
						</Captcha>} */}
						{(isCaptchaRequired) &&
							<Captcha isRTL={isRTL}>
								<div id="recaptcha"></div>
								<SampleDiv setRecaptchaInDom={setRecaptchaInDom} setisCaptchaMounted={setisCaptchaMounted}/>
							</Captcha>}
						{(isCaptchaRequired) && <Verify onClick={()=>{
							onProceed(fieldType, typeof inputValue === "string" ? inputValue : inputValue.toString(), undefined, supportMultipleCountries ? currentPhoneCode : undefined);
						}}>Verify</Verify>}

						{
							showWhatsAppOption && (
								<SelectField
									selected={whatsappUpdate}
									setGetsAppUpdate={() => { setGetWhatsAppUpdate(); setWhatsappUpdate(true); }}
								>
									<FlexCenter>
										<WhatsAppText>
											{dataLocale.GET_UPDATES_ON_WHATSAPP || "Get updates on Whatsapp"}
										</WhatsAppText>
										<img width={25} src="https://static.lenskart.com/media/desktop/img/25-July-19/whatsapp.png" alt="Whatsapp" />
									</FlexCenter>
								</SelectField>
							)
						}
						<Button
							id="remove-button"
							theme={ThemeENUM.primary}
							kind={kindENUM.background}
							showChildren={true}
							font={TypographyENUM.lkSansBold} //onDecreaseItem(item.id)
							width="100"
							disabled={!inputValue || isCaptchaMounted}
							onClick={(e: any) => validateErrors(e, clickHandler)}
							style={{ height: "56px", borderRadius: "100px", fontSize: "16px" }}
						>
							{dataLocale.SIGN_IN_SIGN_UP}
						</Button>
						<Spacer />
						{showGuestFlow && <>{!isHome && !(showOTP || showPassword) && (<EditBtn disabled={signInStatus.isLoading || isCaptchaMounted} fullWidth onClick={(e: any) => validateErrors(e, guestCheckout ? () => guestCheckout({ email: fieldType === SignInType.PHONE ? "" : inputValue.toString(), number: fieldType === SignInType.EMAIL ? null : inputValue.toString() }) : () => null)}>{dataLocale?.CHECKOUT_AS_GUEST}</EditBtn>)}</>}
					</>}
				</CheckoutSigninContainer>}
				{!showOTP && showPassword && <CheckoutSigninContainer className="enterAndEditField" isRTL={isRTL}>
					<SignInHead isCompact signInText={dataLocale?.ENTER_YOUR_PASSWORD} isRTL={isRTL} />
					<EditField isCheckout dataLocale={dataLocale} editEmailIcon={true} onEdit={handleBackClick} label={dataLocale?.PLEASE_ENTER_YOUR_PASSWORD_FOR} mainText={typeof inputValue === "string" ? inputValue : inputValue.toString()} />
					<InputFieldContainer isFullWidth={true} isError={Boolean(error || (signInStatus.isError && signInStatus.errorMessage))} subText={error || (signInStatus.isError && signInStatus.errorMessage ? signInStatus.errorMessage : "")}>
						<TextField autoFoc={true} isRTL={isRTL} value={passwordField} type="password" onChange={(e) => updatePasswordValue(e.target.value)} placeholder={dataLocale?.ENTER_PASSWORD} onKeyUpChange={handleKeyUpOnInput}></TextField>
					</InputFieldContainer>
					<div><EditBtn onClick={() => setShowForgotPassword(true)}>{dataLocale.FORGOT_PASSWORD}</EditBtn></div>
					<Spacer className="space10" />
					{signInStatus.isLoading ? <InlineLoader alt="Loading..." src={loaderImageLink} /> :
						<Button
							id="remove-button"
							theme={ThemeENUM.primary}
							kind={kindENUM.background}
							showChildren={true}
							font={TypographyENUM.lkSansBold}
							width="100"
							onClick={(e: any) => validateErrors(e, clickHandler)}
							style={{ height: "56px", borderRadius: "100px", fontSize: "16px" }}
						>
							{dataLocale.PROCEED}
						</Button>}
					<Spacer className="spacer15" />
					{showGuestFlow && <>{!showHome && !isHome && !(showOTP || showPassword) && <EditBtn fullWidth disabled={signInStatus.isLoading} onClick={(e: any) => validateErrors(e, guestCheckout ? () => guestCheckout({ email: fieldType === SignInType.PHONE ? "" : inputValue.toString(), number: fieldType === SignInType.EMAIL ? null : inputValue.toString() }) : () => null)}>{dataLocale?.CHECKOUT_AS_GUEST}</EditBtn>}</>}
				</CheckoutSigninContainer>}

				<CheckoutSigninContainer className="enterAndEditField">
					{!showOTP && !showPassword && <>
						{!showHome ? <SignInHead signInText={fieldType === SignInType.PHONE ? dataLocale.ENTER_MOBILE_NUMBER : dataLocale.ENTER_EMAIL_ID} isRTL={isRTL} /> : <SignInHead signInText={dataLocale.SIGN_IN} isRTL={isRTL} /> }
						<InputFieldContainer isCheckout gapZero={!isMobileView && supportMultipleCountries} forceLTR={isRTL && fieldType === SignInType.PHONE} isFullWidth={true} isError={Boolean(error || (signInStatus.isError && signInStatus.errorMessage))} subText={error || (signInStatus.isError && signInStatus.errorMessage ? signInStatus.errorMessage : "")}>
							{fieldType === SignInType.PHONE && phoneCodeConfigData && supportMultipleCountries && <PhoneCodeDropdownWrapper top={incCountryCodeFont ? "0" : "2"}><PhoneCodeDropdown isMobileView={isMobileView} width={isMobileView ? "" : "68px"} showSvgArrow = {true} incCountryCodeFont={incCountryCodeFont} availableCountries={phoneCodeConfigData.availableCountries} currentPhoneCode={currentPhoneCode} onChange={(newPhoneCode: string) => setCurrentPhoneCode(newPhoneCode)} /></PhoneCodeDropdownWrapper>}
							{fieldType === SignInType.PHONE ? <TextField isCheckout isRTL={isRTL} value={typeof inputValue === "string" ? inputValue : inputValue.toString()} type={TextTypeENUM.text} onChange={changeInputValue} placeholder={dataLocale?.MOBILE_NO} onKeyUpChange={onKeyUpHandler} onBlur={(e) => {validateErrors(e, () => null); setInputFocused(true);}} maxLength={getNumberLengthFromCode(countryCode)} onKeyPress={(event: any) => {
								const keycode = event.which;
								if (
									!(
										event.shiftKey === false &&
										(keycode === 46 ||
											keycode === 8 ||
											keycode === 37 ||
											keycode === 39 ||
											(keycode >= 48 && keycode <= 57))
									)
								) {
									event.preventDefault();
								}
							}}>
								{fieldType === SignInType.PHONE && !supportMultipleCountries ? countryCode : ""}
							</TextField> : <TextField isCheckout value={typeof inputValue === "string" ? inputValue : inputValue.toString()} type={TextTypeENUM.text} onChange={changeInputValue} onBlur={(e) => {validateErrors(e, () => null); setInputFocused(true);}} placeholder={dataLocale?.EMAIL_ADDRESS} onKeyUpChange={onKeyUpHandler} maxLength={100}>
							</TextField>}
						</InputFieldContainer>
						{/* {signInStatus.isLoading ? <InlineLoader alt="Loading..." src="//static.lenskart.com/skin/frontend/base/default/images/loader2.gif" /> : <Button */}
						{fieldType === SignInType.PHONE && showWhatsAppOption && <SelectField selected={whatsappUpdate}
							setGetsAppUpdate={() => { setGetWhatsAppUpdate(); setWhatsappUpdate(true); }}><FlexCenter><WhatsAppText>{dataLocale.GET_UPDATES_ON_WHATSAPP || "Get updates on Whatsapp"} </WhatsAppText><img width={25} src="https://static.lenskart.com/media/desktop/img/25-July-19/whatsapp.png" alt="Whatsapp"/></FlexCenter></SelectField>}

						{signInStatus.isLoading ? <InlineLoader alt="Loading..." src={loaderImageLink} /> : <>
							<Button
								id="remove-button"
								theme={ThemeENUM.primary}
								kind={kindENUM.background}
								showChildren={true}
								font={TypographyENUM.lkSansBold} //onDecreaseItem(item.id)
								width="100"
								disabled={!inputValue || signInStatus.isLoading }
								onClick={(e: any) => validateErrors(e, clickHandler)}
								style={{ height: "56px", borderRadius: "100px", fontSize: "16px" }}
							>
								{showHome ? dataLocale.SIGN_IN : dataLocale.SIGN_IN_SIGN_UP}
							</Button>
							<Spacer className="spacer5" />
							<Button
								id="remove-button"
								theme={ThemeENUM.secondary}
								kind={kindENUM.border}
								showChildren={true}
								font={TypographyENUM.lkSansBold} //onDecreaseItem(item.id)
								width="100"
								disabled={signInStatus.isLoading}
								onClick={() => {
									setFieldType(fieldType => fieldType === SignInType.EMAIL ? SignInType.PHONE : SignInType.EMAIL);
									setInputValue("");
									setError("");
									if(typeof resetSignInStatus === "function") resetSignInStatus();
								}}
								style={{ height: "56px", borderRadius: "100px", background: "transparent", fontSize: "16px" }}
							>
								{fieldType === SignInType.PHONE ? dataLocale.USE_EMAIL_ADDRESS : dataLocale.USE_MOBILE_NUMBER}
							</Button>
						</>}
						<Spacer />
						{showHome && <><InfoText>{dataLocale.NEW_MEMBER} <EditBtn onClick={moveToSignUp} disabled={signInStatus.isLoading}>{dataLocale.CREATE_ACCOUNT}</EditBtn></InfoText> </>}
						{!showHome && !isHome && homeGuestFlow && <EditBtn fullWidth disabled={!inputValue || signInStatus.isLoading || isCaptchaMounted} onClick={(e: any) => validateErrors(e, guestCheckout ? () => guestCheckout({ email: fieldType === SignInType.PHONE ? "" : inputValue.toString(), number: fieldType === SignInType.EMAIL ? null : inputValue.toString() }) : () => null)}>{dataLocale?.CHECKOUT_AS_GUEST}</EditBtn>}
					</>}
				</CheckoutSigninContainer>
			</SignIn>
		</>
	);
};

export { CheckoutSignIn };
